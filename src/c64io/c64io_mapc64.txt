- C64 I/O Map (Mapping The Commodore 64)
-
- MAPC6410.TXT
-
------------------------------------------------------------
-
# [...]

$D000-$D02E               VIC-II Chip Registers

                          The Video Interface Controller (VIC-II chip) is a specially designed
                          processor that is in charge of the 64's video display.  It is this
                          chip which makes possible the 64's wide range of graphics
                          capabilities.

                          The VIC-II chip's ability to address memory is independent of the 6510
                          microprocessor.  It can address only 16K at a time, and any of the
                          four blocks of 16K can be chosen for video memory.  The system default
                          is for it to use the first 16K.

                          All of the video display memory, character dot data, and sprite shapes
                          must be stored within the chosen 16K block.  Locations 53248-53294
                          ($D000-$D02E) are registers which allow the user to communicate with
                          the VIC-II chip.  Although for the most part they can be written to
                          and read like ordinary memory locations, their contents directly
                          control the video display.  Since many of these locations work in
                          close conjunction with others, a general overview of some of the
                          different graphics systems on the 64 is in order.

                          The most familiar type of graphics display is the ordinary text that
                          appears when you turn the machine on.  The area of RAM which is
                          displayed on the screen is determined by the Video Matrix Base Address
                          Nybble of the VIC-II Memory Control Register (53272, $D018).  The
                          address of the dot-data which is used to assign a shape to each text
                          character based on an 8 by 8 matrix of lit or unlit dots is determined
                          by the other half of the Memory Control Register at 53272 ($D018).
                          More information on how the data is used to represent the character
                          shapes may be found at the alternate entry for 49152 ($C000), the
                          Character Generator ROM.

                          Text character graphics may employ one of the two sets of text and
                          graphics characters in the Character Generator ROM, or the user may
                          substitute a completely different set of graphics or text characters
                          in RAM.

                          Normally, the text graphics screen uses a background color which is
                          common to all text characters, and that value is stored in Background
                          Color Register 0 (53281, $D021).  The color of the frame around the
                          screen is determined by the Border Color Register at 53280 ($D020).

                          The color of each character is determined by one nybble of the Color
                          RAM which starts at 55296 ($D800).  There are, however, two variations
                          which alter this scheme somewhat.

                          The first is called multicolor text mode, and is set by Bit 4 of 53270
                          ($D016).  Instead of each bit selecting either the foreground or the
                          background color for each dot in the character, bit-pairs are used to
                          select one of four colors for each double-width dot.  This results in
                          the horizontal resolution being cut to four dots across per character,
                          but allows two extra colors to be introduced from Background Color
                          Registers 1 and 2 (53282-53283, $D022-$D023).

                          The other text mode is called Extended Background Color Mode.  In this
                          mode, the foreground color is always selected by the Color RAM.  The
                          background color depends on the actual screen code of the character.
                          In this mode, only the first 64 character shapes are available, but
                          each can have one of four different background colors.

                          The background color for each character is determined by its screen
                          code as follows:

                          1.  If the screen code is from 0-63 (this includes the normal
                          alphanumerics), the value in Background Color Register 0 (53281,
                          $D021) will determine the background color, as is usual.

                          2.  Characters with codes 64-255 will have the same shape as the
                          corresponding character in the group with codes 0-63.

                          3.  For characters with codes 64-127 (SHIFTed characters), the
                          background colors are determined by the value in Background Color
                          Register 1 (53282, $D022).

                          4.  The value in Background Color Register 2 (53283, $D023) is used
                          for characters with codes 128-191 (reversed alphanumerics).

                          5.  For characters with codes 192-255, the value in Background Color
                          Register 3 (53284, $D024) is used to determine the background color.


                          In place of the normal text mode, a bitmap graphics mode is also
                          available by setting Bit 5 of location 53265 ($D011).  In this mode,
                          each bit of data determines whether one dot on the screen will be set
                          to either the background color or foreground color.  Within an 8 by 8
                          dot area, the foreground and background colors may be individually
                          selected.

                          The bitmap area is 320 dots wide and 200 dots high.  The area which
                          contains the graphics data, the bitmap, is determined by the Character
                          Dot Data Base Address in the lower nybble of the VIC-II Memory Control
                          Register (53272, $D018).  The Video Matrix Base Address in the upper
                          nybble, which normally determines which area of memory will be
                          displayed, instead determines where the color memory for each 8 by 8
                          ground of dots will be located.

                          The Color RAM is not used for high-resolution bitmap graphics.  But
                          multicolor mode is also available for bitmap graphics, and it uses the
                          Color RAM to determine the foreground color of each dot.

                          As with multicolor text mode, the horizontal resolution is but in half
                          (to 160 dots across), so that in addition to the foreground and
                          background colors, each dot can be one of two other colors as well.
                          This mode gets the value for the two extra colors from the two nybbles
                          of each byte of bitmap color memory, the location of which is
                          determined by the Video Matrix Base Address.

                          Multicolor text mode offers four colors, three of which will be common
                          to all characters, and one of which can be selected individually.
                          Multicolor bitmap mode offers a choice of four colors, three of which
                          can be individually selected within an 8 by 8 dot area.

                          The 64 also contains an entirely separate graphics system, whose
                          character shapes, colors, and positions are derived and displayed
                          without any reference to the Video Matrix and Character Dot-Data
                          addresses.  Best of all, these characters may be moved quickly and
                          easily to any position on the screen, greatly facilitating games and
                          animated graphics of all types.  This system is known as sprite
                          graphics.

                          Sprite graphics takes its name from the graphics characters it
                          displays, each of which is called a sprite.  There are eight sprites,
                          known as Sprites 0-7.  Each sprite character is 24 dots wide by 21
                          dots high.  This is about eight times as large as a regular text
                          character, which is only 8 dots wide by 8 dots high.

                          A sprite takes its shape from 63 bytes of data in one of the 256 data
                          blocks, each 64 bytes long, that can fit into the 16K space which the
                          VIC-II chip can address.  The block currently assigned to any given
                          sprite is determined by the Sprite Data Pointers, which are located at
                          the last eight bytes of the screen memory area (the default locations
                          are 2040-2047, $7F8-$7FF).

                          The first Sprite Data Pointer determines the data block used for the
                          shape of Sprite 0, the second for the shape of Sprite 1, etc.  The
                          number in the pointer times 64 equals the address of the first byte of
                          the data block within the VIC-II addressing range.

                          For example, using the default values for VIC-II addressing area and
                          screen memory, a value of 11 in location 2040 ($7F8) would mean that
                          the shape of Sprite0 is determined by the data in the 63-byte block
                          starting at location 704 (11*64).  It should be noted that it is
                          possible for more than one sprite to take its shape data from the same
                          block, so that only 64 bytes of data are required to create eight
                          sprites, each having the same shape.

                          The dot patterns of each sprite correspond to the bit patterns of the
                          sprite shape data.  Each byte of shape data in memory consists of a
                          number from 0 to 255.  This number can be represented by eight binary
                          digits of 0 or 1.

                          Each binary digit has a bit value that is two times greater than the
                          last.  If the digit in the zero bit place is a 1, it has a value of 1
                          (we count bit places from 0 to 7).  A 1 in the first bit place has a
                          value of 2, the second bit has a value of 4, the third has a value of
                          8, the fourth has a value of 16, the fifth a value of 32, the sixth a
                          value of 64, and the seventh a value of 128.

                          By making all of the possible combinations of 0's and 1's in all eight
                          bit places, and adding the bit values of every bit place that contains
                          a 1, we can represent every number from 0 to 255 as a series of 1's
                          and 0's.

                          If you think of every 0 as a dot having the same color as the
                          background, and every 1 as a dot which is the color of the sprite, you
                          can see how a series of bytes could be used to represent the sprite
                          shape.

                          Since each line of the sprite is 24 dots wide, it takes 3 bytes of
                          memory (24 bits) per line to portray its shape.  Let's take a look at
                          a couple of sample sprite lines.

                          00000000 01111110 00000000 = 0, 126, 0

                          As you can see, the first and last bytes are all 0's, so nothing will
                          be displayed there.  The middle byte has six 1's, so it will be
                          displayed as a line six dots long.  By adding the values of these six
                          bits (64+32+16+8+4+2), we get a byte value of 126.  Let's try another
                          line.

                          00011111 11111111 11111000 = 21, 255, 248

                          The first byte has five bits set to 1, having values of 16, 8, 4, 2,
                          and 1, for a total of 31.  The second byte has all bits set to 1, so
                          it has the maximum value of 255.  The third byte also has five bits
                          set to 1, having values of 128, 64, 32, 16, and 8, for a total of 248.
                          The result is that this line of sprite data will display a line that
                          is 18 dots long.

                          We can put these two kinds of lines together to show how a large cross
                          might be drawn using bytes of sprite data.

                              000000000000000000000000 = 0, 0, 0
                              000000000000000000000000 = 0, 0, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000111111111111111111000 = 21, 255, 248
                              000111111111111111111000 = 21, 255, 248
                              000111111111111111111000 = 21, 255, 248
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000111111000000000 = 0, 126, 0
                              000000000000000000000000 = 0, 0, 0
                              000000000000000000000000 = 0,0,0

                          The 63 numbers, displayed three per line opposite the bit patters they
                          represent, are the values that would have to be put in the sprite
                          shape data area in order to display this cross using sprite graphics.

                          Even after the sprite shape data has been placed in memory, and the
                          Sprite Data Pointer has been set to display that block of data bytes
                          as the sprite shape, there are still several steps that must be taken
                          in order to display the sprite on the screen.

                          The proper bit of the Sprite Display Enable Register at 53269 ($D015)
                          must be set to 1 in order to turn on the sprite display.  A horizontal
                          and vertical screen position must be selected for the sprite by means
                          of the horizontal and vertical position registers (53248-53264,
                          $D000-$D010).  Finally, the color value of the sprite should be placed
                          in the appropriate Sprite Color Register (53287-53294, $D027-$D02E).

                          Once you have the sprite on the screen, animation is fairly simple to
                          achieve.  Moving the sprite is as easy as changing the values in the
                          sprite position registers.  Changing the sprite shape can be
                          accomplished by merely changing the Sprite Data Pointer to point to
                          another block of shape data in memory.

                          There are also some optional sprite graphics features available which
                          enhance its flexibility.  Sprite expand registers allow you to make
                          each sprite twice as wide as normal, twice as tall, or both.
                          Collision detection registers let you know when a sprite shape
                          overlaps a regular text character or bitmap dot, or if two sprites are
                          touching.

                          If a sprite is positioned in the same place on the screen as a text
                          character or bitmap dot, a Priority Register allows you to choose
                          whether the sprite or the normal graphics will be displayed.  This
                          enables three- dimensional effects by letting you choose whether the
                          sprite goes in front of or behind other objects on the screen.

                          Finally, any sprite may be selected for multicolor display, using the
                          register at location 53276 ($D01C).  In this mode, as in multicolor
                          text and bitmap modes, pairs of bits are used to determine the color
                          of each double- width dot.  The possible color values which may be
                          selected are those of Background Color Register 0, the Sprite Color
                          Register, or the two color values in the Sprite Multicolor Registers
                          at 53285-53286 ($D025-$D026).

$D000-$D010               Sprite Horizontal and Vertical Position Registers

                          These locations determine the horizontal and vertical position at
                          which each sprite will be displayed on the screen.  Each sprite has
                          its own horizontal and vertical position register.  In addition, all
                          of the sprites share a common register which is used to extend the
                          range of horizontal positions.

                          Vertical positions for each sprite range from 0 to 255, and these
                          indicate the vertical position of the top line of the sprite's 21-line
                          length.  Since there are only 200 visible scan lines in the screen
                          display, some of these vertical positions will result in the sprite
                          being partially or wholly offscreen.

                          The visible viewing area starts at line 50 and extends to line 249.
                          Therefore, any sprite whose vertical position is 29 ($1D) or less will
                          be completely above the visible picture.  At vertical position 30
                          ($1E), the bottom line of the sprite display becomes visible at the
                          top of the screen.  At position 230 ($E6), the bottom line of the
                          sprite is lost from view off the bottom of the screen, and at vertical
                          position 250 ($FA), the entire sprite disappears from view off the
                          bottom edge of the screen.

                          Horizontal positioning is somewhat trickier, because the visible
                          display area is 320 dots wide, and one eight-bit register can hold
                          only 256 position values.  Therefore, an additional register is needed
                          to hold the ninth bit of each sprite's horizontal position.

                          Each sprite is assigned a single bit in the Most Significant Bit of
                          Horizontal Position register (MSB register) at 53264 ($D010).  If that
                          bit is set to 1, the value 256 is added to the horizontal position.
                          This extends the range of possible horizontal positions to 511.

                          In order to set a sprite's horizontal position, you must make sure
                          that both the values in the horizontal position register and the MSB
                          Register are correct.  For example, if you wish to set the horizontal
                          position of Sprite 5 to a value of 30, you must place a value of 30 in
                          the Sprite 5 Horizontal Position Register (POKE 53258,30 will do it
                          from BASIC), and you must also clear Bit 5 of the MSB Register (POKE
                          53264,PEEK(53264)AND(255-16)).  If you forget the MSB register, and
                          Bit 5 is set to 1, you will end up with position 286 instead of 30.

                          The horizontal position value indicates the position of the leftmost
                          dot of the sprite's 24-dot width.  The visible display is restricted
                          to the 320 dot positions between positions 24 and 344.  At position 0
                          the whole sprite is past the left edge of the visible screen.  At
                          position 1 the rightmost dot enters the display area, and at position
                          24 ($18) the entire sprite is displayed on screen.  At position 321
                          ($141) the rightmost dot goes past the right edge of the visible
                          display area, and a position 355 ($158) the whole sprite has moved out
                          of sight, off the right edge of the screen.

                          These registers are all initialized to 0 at power-up.

$D000        SP0X         Sprite 0 Horizontal Position

$D001        SP0Y         Sprite 0 Vertical Position

$D002        SP1X         Sprite 1 Horizontal Position

$D003        SP1Y         Sprite 1 Vertical Position

$D004        SP2X         Sprite 2 Horizontal Position

$D005        SP2Y         Sprite 2 Vertical Position

$D006        SP3X         Sprite 3 Horizontal Position

$D007        SP3Y         Sprite 3 Vertical Position

$D008        SP4X         Sprite 4 Horizontal Position

$D009        SP4Y         Sprite 4 Vertical Position

$D00A        SP5X         Sprite 5 Horizontal Position

$D00B        SP5Y         Sprite 5 Vertical Position

$D00C        SP6X         Sprite 6 Horizontal Position

$D00D        SP6Y         Sprite 6 Vertical Position

$D00E        SP7X         Sprite 7 Horizontal Position

$D00F        SP7Y         Sprite 7 Vertical Position

$D010        MSIGX        Most Significant Bits of Sprites 0-7 Horizontal Position

                     0    Most significant bit of Sprite 0 horizontal position
                     1    Most significant bit of Sprite 1 horizontal position
                     2    Most significant bit of Sprite 2 horizontal position
                     3    Most significant bit of Sprite 3 horizontal position
                     4    Most significant bit of Sprite 4 horizontal position
                     5    Most significant bit of Sprite 5 horizontal position
                     6    Most significant bit of Sprite 6 horizontal position
                     7    Most significant bit of Sprite 7 horizontal position

                          Setting one of these bites to 1 adds 256 to the horizontal position of
                          the corresponding sprite.  Resetting one of these bits to 0 restricts
                          the horizontal position of the corresponding sprite to a value of 255
                          or less

$D011        SCROY        Vertical Fine Scrolling and Control Register

                     0-2  Fine scroll display vertically by X scan lines (0-7)
                     3    Select a 24-row or 25-row text display (1=25 rows, 0=24 rows)
                     4    Blank the entire screen to the same color as the background
                            (0=blank)
                     5    Enable bitmap graphics mode (1=enable)
                     6    Enable extended color text mode (1=enable)
                     7    High bit (Bit 8) of raster compare register at 53266 ($D012)

                          This is one of the two important multifunction control registers on
                          the VIC-II chip.  Its default value is 155, which sets the high bit of
                          the raster compare to 1, selects a 25-row display, disables the
                          blanking feature, and uses a vertical scrolling offset of three scan
                          lines.

                          Bits 0-2.  These bits control vertical fine scrolling of the screen
                          display.  This feature allows you to move the entire text display
                          smoothly up and down, enabling the display area to act as a window,
                          scrolling over a larger text or character graphics display.

                          Since each row of text is eight scan lines high, if you simply move
                          each line of text up one row, the characters travel an appreciable
                          distance each time they move, which gives the motion a jerky quality.
                          This is called coarse scrolling, and you can see an example of it when
                          LISTing a program that is too long to fit on the screen all at one
                          time.

                          By placing a number from 1 to 7 into these three bits, you can move
                          the whole screen display down by from 1 to 7 dot spaces.  Stepping
                          through the values 1 to 7 allows you to smoothly make the transition
                          from having a character appear in one row on the screen to having it
                          appear in the next row.  To demonstrate this, type in the following
                          sample program, LIST it, and RUN.

                              10 FOR I= 1 TO 50:FOR J=0 TO 7
                              20 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I
                              30 FOR I= 1 TO 50:FOR J=7 TO 0 STEP-1
                              40 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I

                          As you can see, after the display has moved seven dot positions up or
                          down, it starts over at its original position.  In order to continue
                          the scroll, you must do a coarse scroll every time the value of the
                          scroll bits goes from 7 to 0, or from 0 to 7.  This is accomplished by
                          moving the display data for each line by 40 bytes in either direction,
                          overwriting the data for the last line, and introducing a line of data
                          at the opposite end of screen memory to replace it.  Obviously, only a
                          machine language program can move all of these lines quickly enough to
                          maintain the effect of smooth motion.  The following BASIC program,
                          however, will give you an idea of what vertical fine scrolling is like:

                              10 POKE 53281,0:PRINTCHR$(5);CHR$(147)
                              20 FORI=1 TO 27:
                              30 PRINTTAB(15)CHR$(145)"            ":POKE 53265,PEEK(53265)AND248
                              40 WAIT53265,128:PRINTTAB(15)"I'M FALLING"
                              50 FOR J=1 TO 7
                              60 POKE53265,(PEEK(53265)AND248)+J
                              70 FORK=1TO50
                              80 NEXT K,J,I:RUN

                          Bit 3.  This bit register allows you to select either the normal
                          25-line text display (by setting the bit to 1), or a shortened 24-row
                          display (by resetting that bit to 0).  This shortened display is
                          created by extending the border to overlap the top or bottom row.  The
                          characters in these rows are still there; they are just covered up.

                          The shortened display is designed to aid vertical fine scrolling.  It
                          covers up the line into which new screen data is introduced, so that
                          the viewer does not see the new data being moved into place.

                          However, unlink the register at 53270 ($D016) which shortens the
                          screen by one character space on either side to aid horizontal
                          scrolling in either direction, this register can blank only one
                          vertical line at a time.  In order to compensate, it blanks the top
                          line when the three scroll bits in this register are set to 0, and
                          shifts the blanking one scan line at a time as the value of thee bits
                          increases.  Thus the bottom line is totally blanked when these bits
                          are set to 7.

                          Bit 4.  Bit 4 of this register controls the screen blanking feature.
                          When this bit is set to 0, no data can be displayed on the screen.
                          Instead, the whole screen will be filled with the color of the frame
                          (which is controlled by the Border Color Register at 53280 ($D020)).

                          Screen blanking is useful because of the way in which the VIC-II chip
                          interacts with the 6510 microprocessor.  Since the VIC-II and the 6510
                          both have to address the same memory, they must share the system data
                          bus.  Sharing the data bus means that they must take turns whenever
                          they want to address memory.

                          The VIC-II chip was designed so that it fetches most of the data it
                          needs during the part of the cycle in which the 6510 is not using the
                          data bus.  But certain operations, such as reading the 40 screen codes
                          needed for each line of text from video memory, or fetching sprite
                          data, require that the VIC-II chip get data at a faster rate than is
                          possible just by using the off half of the 6510 cycle.

                          Thus, the VIC-II chip must delay the 6510 for a short amount of time
                          while it is using the data bus to gather display information for text
                          or bitmap graphics, and must delay it a little more if sprites are
                          also enabled.  When you set the screen blanking bit to 0, these delays
                          are eliminated, and the 6510 processor is allowed to run at its full
                          speed.  This speeds up any processing task a little.

                          To demonstrate this, run the following short program.  As you will
                          see, leaving the screen on makes the processor run about 7 percent
                          slower than when you turn it off.  If you perform the same timing test
                          on the VIC-20, you will find that it runs at the same speed with its
                          screen on as the 64 does with its screen off.  And the same test on a
                          PET will run substantially slower.

                              10 PRINT CHR$(147);TAB(13);"TIMING TEST":PRINT:TI$="000000":GOTO 30
                              20 FOR I=1 TO 10000:NEXT I:RETURN
                              30 GOSUB 20:DISPLAY=TI
                              40 POKE 53265,11:TI$="000000"
                              50 GOSUB 20:NOSCREEN=TI:POKE 53265,27
                              60 PRINT "THE LOOP TOOK";DISPLAY;" JIFFIES"
                              70 PRINT "WITH NO SCREEN BLANKING":PRINT
                              80 PRINT "THE LOOP TOOK";NOSCREEN;" JIFFIES"
                              90 PRINT "WITH SCREEN BLANKING":PRINT
                              100 PRINT "SCREEN BLANKING MAKE THE PROCESSOR"
                              110 PRINT "GO";DISPLAY/NOSCREEN*100-100;"PERCENT FASTER"

                          The above explanation accounts for the screen being turned off during
                          tape read and write operations.  The timing of these operations is
                          rather critical, and would be affected by even the relatively small
                          delay caused by the video chip.  It also explains why the 64 has
                          difficulty loading programs from an unmodified 1540 Disk Drive, since
                          the 1540 was set up to transfer data from the VIC-20, which does not
                          have to contend with these slight delays.

                          If you turn off the 64 display with a POKE 53265,PEEEK(53265) AND 239,
                          you will be able to load programs correctly from an old 1540 drive.
                          The new 1541 drive transfers data at a slightly slower rate in the
                          default setting, and can be set from software to transfer it at the
                          higher rate for the VIC-20.

                          Bit 5.  Setting Bit 5 of this register to 1 enables the bitmap
                          graphics mode.  In this mode, the screen area is broken down into
                          64,000 separate dots of light, 320 dots across by 200 dots high.  Each
                          dot corresponds to one bit of display memory.  If the bit is set to 1,
                          the dot will be displayed in the foreground color.  If the bit is
                          reset to 0, it will be displayed in the background color.  This allows
                          the display of high-resolution graphics images for games, charts, and
                          graphs, etc.

                          Bitmapping is a common technique for implementing high-resolution
                          graphics on a microcomputer.  There are some features of the Commodore
                          system which are unusual, however.

                          Most systems display screen memory sequentially; that is, the first
                          byte controls the display of the first eight dots in the upper-left
                          corner of the screen, the second byte controls the eight dots to the
                          right of that, etc.  In the Commodore system, display memory is laid
                          out more along the lines of how character graphics dot-data is
                          arranged.

                          The first byte controls the row of eight dots in the top-left corner
                          of the screen, but the next byte controls the eight dots below that,
                          and so on until the ninth byte.  The ninth byte controls the eight
                          dots directly to the right of those controlled by the first byte of
                          display memory.  It is exactly the same as if the screen were filled
                          with 1000 programmable characters, with display memory taking the
                          place of the character dot-data.

                          The 64's bitmap graphics mode also resembles character graphics in
                          that the foreground color of the dots is set by a color map (although
                          it does not use the Color RAM for this purpose).  Four bits of each
                          byte of this color memory control the foreground color of one of these
                          eight-byte groups of display memory (which form an 8 by 8 grid of 64
                          dots).  Unlike character graphics, however, the other four bits
                          control the background color that will be seen in the eight-byte
                          display group where a bit has a value of 0.

                          Setting up a bitmap graphics screen is somewhat more complicated than
                          just setting this register bit to 1.  You must first choose a location
                          for the display memory area, and for the color memory area.  The
                          display memory area will be 8192 bytes long (8000 of which are
                          actually used for the display) and can occupy only the first or the
                          second half of the 16K space which the VIC-II chip can address.

                          Each byte of bitmap graphics color memory uses four bits for the
                          background color as well as four bits for the foreground color.
                          Therefore, the Color RAM nybbles at 55296 ($D800), which are wired for
                          four bits only, cannot be used.  Another RAM location must therefore
                          be found for color memory.

                          This color memory area will take up 1K (1000 bytes of which are
                          actually used to control the foreground and background colors of the
                          dots), and must be in the opposite half of VIC-II memory as the
                          display data.  Since bitmap graphics require so much memory for the
                          display, you may want to select a different 16K bank for VIC-II memory
                          (see the discussion of things to consider in selecting a VIC-II memory
                          bank at location 56576 ($DD00)).

                          To keep things simple, however, let's assume that you have selected to
                          use the default bank of VIC-II memory, which is the first 16K.  You
                          would have to select locations 8192-16383 ($2000-$3FFF) for screen
                          memory, because the VIC-II chip sees an image of the character ROM in
                          the first half of the 16K block (at locations 4096-8192
                          ($1000-$1FFF)).  Color memory could be placed at the default location
                          of text display memory, at 1024-2047 ($400-$7FF).  Placement of bitmap
                          display and color memory is controlled by the VIC Memory Control
                          Register at 53272 ($D018).

                          When in bitmap mode, the lower four bits of this register, which
                          normally control the base address of character dot-data, now control
                          the location of the 8K bitmap.  Only Bit 3 is significant.  If it is
                          set to 1, the graphics display memory will be in the second 8K of
                          VIC-II memory (in this case, starting at 8192 ($2000)).  If that bit
                          contains a 0, the first 8K will be used for the bitmap.  The upper
                          four bits of this register, which normally control the location of the
                          Video Display Matrix, are used in bitmap mode to establish the
                          location of the color map within the VIC-II address space.  These four
                          bits can hold a number from 0 to 15, which indicates on which 1K
                          boundary the color map begins.  For example, if color memory began at
                          1024 (1K), the value of these four bits would be 0001.

                          Once the bitmap mode has been selected, and the screen and color
                          memory areas set up, you must establish a method for turning each
                          individual dot on and off.  The conventional method for identifying
                          each dot is to assign it to a horizontal (X) position coordinate and a
                          vertical (Y) coordinate.

                          Horizontal position values will range from 0 to 319, where dot 0 is at
                          the extreme left-hand side of the screen, and dot 319 at the extreme
                          right.  Vertical positions will range from 0 to 199, where dot 0 is on
                          the top line, and dot 199 is on the bottom line.

                          Because of the unusual layout of bitmap screen data on the 64, it is
                          fairly easy to transfer text characters to a bitmap screen, but it is
                          somewhat awkward finding the bit which affects the screen dot having a
                          given X-Y coordinate.  First, you must find the byte BY in which the
                          bit resides, and then you must POKE a value into that byte which turns
                          the desired bit on or off.  Given that the horizontal position of the
                          dot is stored in the variable X, its vertical position is in the
                          variable Y, and the base address of the bitmap area is in the variable
                          BASE, you can find the desired byte with the formula:

                          BY=BASE+40*(Y AND 256)+(Y AND 7)+(X AND 504)

                          To turn on the desired dot,

                              POKE BY, PEEK(BY) OR (2^(NOTX AND 7)

                          To turn the dot off,

                              POKE BY, PEEK(BY) AND (255-2^(NOTX AND 7))

                          The exponentiation function takes a lot of time.  To speed things up,
                          an array can be created, each of whose elements corresponds to a power
                          of two.

                              FOR I=0 TO 7:BIT(I)=2^1:NEXT

                          After this is done, the expression 2^(I) can be replaced by BI(I).

                          The following sample program illustrates the bit-graphics concepts
                          explained above, and serves as a summary of that information.

                              10 FOR I=0 TO 7:BI(I)=2^I:NEXT: REM SET UP ARRAY OF POWERS OF 2 (BIT VALUE)
                              20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
                              30 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE
                              40 A$="":FOR I=1 TO 37:A$=A$+"C":NEXT:PRINT CHR$(19);
                              50 FOR I=1 TO 27:PRINTA$;:NEXT:POKE2023,PEEK(2022): REM SET COLOR MAP
                              60 A$="":FOR I=1 TO 27:A$=A$+"@":NEXT:FOR I=32 TO 63 STEP 2
                              70 POKE648,I:PRINT CHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLEAR HI-RES      SCREEN
                              80 FORY=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM
                              90 X=INT(160+40*SIN(Y/10)): REM SINE WAVE SHAPE
                              100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504): REM FIND HI-RES BYTE
                              110 POKEBY,PEEK(BY)OR(BI(NOT X AND 7)):NEXT Y:REM POKE IN BIT VALUE
                              120 GOTO 120: REM LET IT STAY ON SCREEN

                          As you can see, using BASIC to draw in bit-graphics mode is somewhat
                          slow and tedious.  Machine language is much more suitable for
                          bit-graphics plotting.  For a program that lets you replace some BASIC
                          commands with high-res drawing commands, see the article "Hi-Res
                          Graphics Made Simple," by Paul F. Schatz, in COMPUTE!'s First Book of
                          Commodore 64 Sound and Graphics.

                          There is a slightly lower resolution bitmap graphics mode available
                          which offers up to four colors per 8 by 8 dot matrix.  To enable this
                          mode, you must set the multicolor bit (Bit 4 of 53270 ($D016)) while
                          in bitmap graphics mode.  For more information on this mode, see the
                          entry for the multicolor enable bit.

                          Bit 6.  This bit of this register enables extended background color
                          mode.  This mode lets you select the background color of each text
                          character, as well as its foreground color.  It is able to increase
                          the number of background colors displayed, by reducing the number of
                          characters that can be shown on the screen.

                          Normally, 256 character shapes can be displayed on the screen.  You
                          can use them either by using the PRINT statement or by POKEing a
                          display code from 0 to 255 into screen memory.  If the POKEing method
                          is used, you must also POKE a color code from 0 to 15 into color
                          memory (for example, if you POKE 1024,1, and POKE 55296,1, a white A
                          appears in the top-left corner of the screen).

                          The background color of the screen is determined by Background Color
                          Register 0, and you can change this color by POKEing a new value to
                          that register, which is located at 53281 ($D021).  For example, POKE
                          53281,0 creates a black background.

                          When extended background color mode is activated, however, only the
                          first 64 shapes found in the table of the screen display codes can be
                          displayed on the screen.  This group includes the letters of the
                          alphabet, numerals, and punctuation marks.  If you try to print on the
                          screen a character having a higher display code, the shape displayed
                          will be from the first group of 64, but that character's background
                          will no longer be determined by the register at 53281 ($D021).
                          Instead, it will be determined by one of the other background color
                          registers.

                          When in extended background color mode, characters having display
                          codes 64- 127 will take their background color from register 1, and
                          location 53282 ($D022).  These characters include various SHIFTed
                          characters.  Those with codes 128-191 will have their background
                          colors determined by register 2, at 53283 ($D023).  These include the
                          reversed numbers, letters, and punctuation marks.  Finally, characters
                          with codes 192-255 will use register 4, at 53284 ($D024).  These are
                          the reversed graphics characters.

                          Let's try an experiment to see just how this works.  First, we will
                          put the codes for four different letters in screen memory:

                              FOR I=0 TO 3:POKE 1230+(I*8),I*64+I:POKE 55502+(I*8),1:NEXT

                          Four white letters should appear on the screen, an A, a shifted A, a
                          reversed A, and a reversed, shifted A, all on a blue background.
                          Next, we will put colors in the other background color registers:

                              POKE 53282,0:POKE53283,2:POKE53284,5

                          This sets the registers to black, red, and green, respectively.
                          Finally, we will activate extended color mode by setting Bit 6 of the
                          VIC-II register at location 53265 to a 1.  The BASIC statement that
                          turns this mode on is:

                              POKE 53265,PEEK(53265) OR 64

                          Notice that two things happened.  First, all of the letters took on
                          the same shape, that of the letter A.  Second, each took on the
                          background color of a different color register.  To get things back to
                          normal, turn off extended color mode with this statement:

                              POKE 53265,PEEK(53265) AND 191

                          Extended color mode can be a very useful enhancement for your text
                          displays.  It allows the creation of windows.  These windows, because
                          of their different background colors, make different bodies of text
                          stand out as visually distinct from one another.  For example, a text
                          adventure program could have one window to display the player's
                          current location, one to show an inventory of possessions, and one to
                          accept commands for the next move.

                          In this mode the background color of these windows can be changed
                          instantly, just by POKEing a new value to the color register.  This
                          technique lends itself to some dramatic effects.  A window can be
                          flashed to draw attention to a particular message at certain times.
                          And varying the foreground color can make either the window or the
                          message vanish and reappear later.

                          There are, however, a couple of problems involved in using these
                          windows.  The character shape that you want to use might not have a
                          screen code of less than 64.  In that case, the only solution is to
                          define your own character set, with the shape you want in one of the
                          first 64 characters.

                          Another problem is that characters within a PRINT statement in your
                          program listing are not always going to look the same on the screen.
                          Having to figure out what letter to print to get the number 4 with a
                          certain background color can be very inconvenient.  The easiest
                          solution to this problem is to have a subroutine to the translation
                          for you.  Since letters will appear normally in window 1, and window 3
                          characters are simply window 1 characters reversed, you will only have
                          problems with characters in windows 2 and 4.  To convert these
                          characters, put your message in A$, and use the following subroutine:

                          500 B$="":FOR I=1 TO LEN(A$):B=ASC(MID$(A$,I,1))
                          510 B=B+32:IF B<96 THEN B=B+96
                          520 B$=B$+CHR$(B):NEXT I:RETURN

                          This subroutine converts each letter to its ASCII equivalent, adds the
                          proper offset, and converts it back to part of the new string, B$.
                          When the conversion is complete, B$ will hold the characters necessary
                          to PRINT that message in window 2.  For window 4, PRINT
                          CHR$(18);B$;CHR$(146).  This will turn reverse video on before
                          printing the string, and turn it off afterwards.

                          A practical demonstration of the technique for setting up windows is
                          given in the sample program below.  The program sets up three windows,
                          and shows them flashing, appearing and disappearing.

                              5 DIM RO$(25):RO$(0)=CHR$(19):FOR I=1 TO 24:RO$(I)=RO$(I-1)+CHR$(17):NEXT
                              10 POKE 53265,PEEK(53265) OR 64
                              20 POKE 53280,0:POKE 53281,0:POKE 53282,1:POKE 53283,2:POKE 53284,13
                              25 OP$=CHR$(160):FOR I=1 TO 4:OP$=OP$:NEXTI:PRINTCHR$(147);RO$(3);
                              30 FOR I=1 TO10:PRINTTAB(1);CHR$(18);"               ";TAB(23);OP$:NEXT
                              40 PRINT CHR$(146):PRINT:PRINT:FOR I=1 TO 4:PRINTOP$;OP$;OP$;OP$;OP$;:NEXTI
                              50 PRINT RO$(5);CHR$(5);CHR$(18);TAB(2);"A RED WINDOW"
                              60 PRINT CHR$(18);TAB(2);"COULD BE USED"
                              70 PRINT CHR$(18);TAB(2);"FOR ERROR"
                              80 PRINT CHR$(18);TAB(2);"MESSAGES"
                              100 A$="A GREEN WINDOW":GOSUB 300:PRINT      RO$(5);CHR$(144);CHR$(18);TAB(24);B$
                              110 A$="COULD BE USED":GOSUB 300:PRINTTAB(24);CHR$(18);B$
                              120 A$="TO GIVE":GOSUB 300:PRINTTAB(24);CHR$(18);B$
                              130 A$="INSTRUCTIONS":GOSUB 300:PRINTTAB(24);CHR$(18);B
                              140 PRINT CHR$(31);RO$(19);
                              150 A$="  WHILE THE MAIN WINDOW COULD BE USED":GOSUB 300:PRINT B$
                              160 A$="  FOR ACCEPTING COMMANDS.":GOSUB 300:PRINT B$
                              170 FOR I=1 TO 5000:NEXT I:POKE 53284,0
                              180 FOR I=1 TO 5:FOR J=1 TO 300:NEXT J:POKE 53282,15
                              190 FOR J=1 TO 300:NEXT J:POKE 53282,1
                              200 NEXT I:POKE 53283,-2*(PEEK(53283)=240):POKE 53284,-13*(PEEK(53284)=240)
                              210 GOTO 180
                              300 B$="":FOR I=1TOLEN(A$):B=ASC(MID$(A$,I,1))
                              310 B=B+32:IFB<96THENB=B+96
                              320 B$=B$+CHR$(B):NEXTI:RETURN

                          Bit 7.  Bit 7 of this register is the high-order bit (Bit 8) of the
                          Raster Compare register at 53266 ($D012).  Even though it is located
                          here, it functions as part of that register (see the description below
                          for more information on the Raster Compare register).

                          Machine language programmers should note that its position here at Bit
                          7 allows testing this bit with the Negative flag.  Since scan lines
                          above number 256 are all off the screen, this provides an easy way to
                          delay changing the graphics display until the scan is in the vertical
                          blanking interval and the display is no longer being drawn:

                              LOOP  LDA $D011
                                    BPL LOOP

                          Sprites should always be moved when the raster is scanning off-screen,
                          because if they are moved while they are being scanned, their shapes
                          will waver slightly.

                          The BASIC equivalent of the program fragment above is the statement
                          WAIT 53265,128, but BASIC is usually not fast enough to execute the
                          next statement while still in the blanking interval.

$D012        RASTE        Read Current Raster Scan Line/Write Line to Compare for Raster IRQ

                          The Raster Compare register has two different functions, depending on
                          whether you are reading from it or writing to it.  When this register
                          is read, it tells which screen line the electron beam is currently
                          scanning.

                          There are 262 horizontal lines which make up the American (NTSC)
                          standard display screen (312 lines in the European or PAL standard
                          screen).  Every one of these lines is scanned and updated 60 times per
                          second.  Only 200 of these lines (numbers 50-249) are part of the
                          visible display.

                          It is sometimes helpful to know just what line is being scanned,
                          because changing screen graphics on a particular line while that line
                          is being scanned may cause a slight disruption on the screen.  By
                          reading this register, it is possible for a machine language program
                          to wait until the scan is off the bottom of the screen before changing
                          the graphics display.

                          It is even possible for a machine language program to read this
                          register, and change the screen display when a certain scan line is
                          reached.  The program below uses this technique to change the
                          background color in midscreen, in order to show all 256 combinations
                          of foreground and background text colors at once.

                              40 FOR I=49152 TO 49188:READ A:POKE I,A:NEXT:POKE 53280,11
                              50 PRINT CHR$(147):FOR I=1024 TO I+1000:POKE I,160:POKE I+54272,11:NEXT I
                              60 FOR I=0 TO 15:FOR J=0 TO 15
                              70 P=1196+(48*I)+J:POKE P,J+I:POKE P+54272,J:NEXT J,I
                              80 PRINT TAB(15)CHR$(5)"COLOR CHART":FOR I=1 TO 19:PRINT:NEXT
                              85 PRINT "THIS CHART SHOWS ALL COMBINATIONS OF   "
                              86 PRINT "FOREGROUND AND BACKGROUND COLORS.      "
                              87 PRINT "FOREGROUND INCREASES FROM LEFT TO RIGHT"
                              88 PRINT "BACKGROUND INCREASES FROM TOP TO BOTTOM"
                              90 SYS 12*4096
                              100 DATA 169,90,133,251,169,0,141,33,208,162,15,120,173,17,208,48
                              105 DATA 251,173,18,208
                              110 DATA 197,251,208,249,238,33,208,24,105,8,133,251,202,16,233,48,219

                          Writing to this register designates the comparison value for the
                          Raster Compare Interrupt.  When that interrupt is enabled, a maskable
                          interrupt request will be issued every time the electron beam scan
                          reaches the scan line whose number was written here.  This is a much
                          more flexible technique for changing the display in midscreen than
                          reading this register as the sample program above does.  That
                          technique requires that the program continuously watch the Raster
                          Register, while the interrupt method will call the program when the
                          time is right to act.  For more information on raster interrupts, see
                          the entry for the Interrupt Mask Register (53274, $D01A).

                          It is very important to remember that this register requires nine
                          bits, and that this location only holds eight of those bits (the ninth
                          is Bit 7 of 53265 ($D011)).  If you forget to read or write to the
                          ninth bit, your results could be in error by a factor of 256.

                          For example, some early programs written to demonstrate the raster
                          interrupt took for granted that the ninth bit of this register would
                          be set to 0 on power-up.  When a later version of the Kernal changed
                          this initial value to a 1, their interrupt routines, which were
                          supposed to set the raster interrupt to occur at scan line number 150,
                          ended up setting it for line number 406 instead.  Since the scan line
                          numbers do not go up that high, no interrupt request was ever issued
                          and the program did not work.

$D013-$D014               Light Pen Registers

                          A light pen is an input device that can be plugged into joystick
                          Control Port #1.  It is shaped like a pen and has a light-sensitive
                          device at its tip that causes the trigger switch of the joystick port
                          to close at the moment the electron beam that updates the screen
                          display strikes it.  The VIC-II chip keeps track of where the beam is
                          when that happens, and records the corresponding horizontal and
                          vertical screen coordinates in the registers at these locations.

                          A program can read the position at which the light pen is held up to
                          the screen.  The values in these registers are updated once every
                          screen frame (60 times per second).  Once the switch is closed and a
                          value written to these registers, the registers are latched, and
                          subsequent switch closings during the same screen frame will not be
                          recorded.

                          A given light pen may not be entirely accurate (and the operator may
                          not have a steady hand).  It is probably wise to average the positions
                          returned from a number of samplings, particularly when using a machine
                          language driver.

$D013        LPENX        Light Pen Horizontal Position

                          This location holds the horizontal position of the light pen.  Since
                          there are only eight bits available (which give a range of 256 values)
                          for 320 possible horizontal screen positions, the value here is
                          accurate only to every second dot position.  The number here will
                          range from 0 to 160 and must be multiplied by 2 in order to get a
                          close approximation of the actual horizontal dot position of the light
                          pen.

$D014        LPENY        Light Pen Vertical Position

                          This location holds the vertical position of the light pen.  Since
                          there are only 200 visible scan lines on the screen, the value in this
                          register corresponds exactly to the current raster scan line.

$D015        SPENA        Sprite Enable Register

                     0    Enable Sprite 0 (1=sprite is on, 0=sprite is off)
                     1    Enable Sprite 1 (1=sprite is on, 0=sprite is off)
                     2    Enable Sprite 2 (1=sprite is on, 0=sprite is off)
                     3    Enable Sprite 3 (1=sprite is on, 0=sprite is off)
                     4    Enable Sprite 4 (1=sprite is on, 0=sprite is off)
                     5    Enable Sprite 5 (1=sprite is on, 0=sprite is off)
                     6    Enable Sprite 6 (1=sprite is on, 0=sprite is off)
                     7    Enable Sprite 7 (1=sprite is on, 0=sprite is off)

                          In order for any sprite to be displayed, the corresponding bit in this
                          register must be set to 1 (the default for this location is 0).  Of
                          course, just setting this bit along will not guarantee that a sprite
                          will be shown on the screen.  The Sprite Data Pointer must indicate a
                          data area that holds some values other than 0.  The Sprite Color
                          Register must also contain a value other than that of the background
                          color.  In addition, the Sprite Horizontal and Vertical Position
                          Registers must be set for positions that lie within the visible screen
                          range in order for a sprite to appear on screen.

$D016        SCROLX       Horizontal Fine Scrolling and Control Register

                     0-2  Fine scroll display horizontally by X dot positions (0-7)
                     3    Select a 38-column or 40-column text display (1=40 columns,
                            0=38 columns)
                     4    Enable multicolor text or multicolor bitmap mode (1=multicolor on,
                            0=multicolor off)
                     5    Video chip reset (0=normal operations, 1=video completely off)
                     6-7  Unused

                          This is one of the two important multifunction control registers on
                          the VIC-II chip.  On power-up, it is set to a default value of 8,
                          which means that the VIC chip Reset line is set for a normal display,
                          Multicolor Mode is disabled, a 40-column text display is selected, and
                          no horizontal fine-scroll offset is used.

                          Bits 0-2.  The first three bits of this chip control vertical fine
                          scrolling of the screen display.  This feature allows you to smoothly
                          move the entire text display back and forth, enabling the display area
                          to act as a window, scrolling over a larger text or character graphics
                          display.

                          Since each text character is eight dots wide, moving each character
                          over one whole character position (known as coarse scrolling) is a
                          relatively big jump, and the motion looks jerky.  By placing a number
                          from 1 to 7 into these three bits, you can move the whole screen
                          display from one to seven dot spaces to the right.

                          Stepping through values 1 to 7 allows you to smoothly make the
                          transition from having a character appear at one screen column to
                          having it appear at the next one over.  To demonstrate this, type in
                          the following program, LIST, and RUN it.

                              10 FOR I=1 TO 50:FOR J=0 TO 7
                              20 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I
                              30 FOR I=1 TO 50:FOR J=7 TO 0 STEP-1
                              40 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I

                          As you can see, after the display has moved over seven dots, it starts
                          over at its original position.  In order to continue with the scroll,
                          you must do a coarse scroll every time the value of the scroll bits
                          goes from 7 to 0, or from 0 to 7.  This is accomplished by moving each
                          byte of display data on each line over one position, overwriting the
                          last character, and introducing a new byte of data on the opposite end
                          of the screen line to replace it.

                          Obviously, only a machine language program can move all of these bytes
                          quickly enough to maintain the effect of smooth motion.  The following
                          BASIC program, however, will give you an idea of what the combination
                          of fine and coarse scrolling looks like.

                              10 POKE 53281,0:PRINT CHR$(5);CHR$(147):FOR I=1 TO 5:PRINT CHR$(17):NEXT
                              20 FOR I=1 TO 30
                              30 PRINT TAB(I-1)"{UP}{10 SPACES}{UP}"
                              40 WAIT53265,128:POKE53270,PEEK(53270)AND248:PRINTTAB(I)"AWAY WE GO"
                              50 FOR J=1 TO 7
                              60 POKE 53270,(PEEK(53270)AND248)+J
                              70 FORK=1TO30-I
                              80 NEXT K,J,I:RUN

                          Changing the value of the three horizontal scroll bits will affect the
                          entire screen display.  If you wish to scroll only a portion of the
                          screen, you will have to use raster interrupts (see 53274 ($D01A)
                          below) to establish a scroll zone, change the value of these scroll
                          bits only when that zone is being displayed, and change it back to 0
                          afterward.

                          Bit 3.  Bit 3 of this register allows you to cover up the first and
                          last columns of the screen display with the border.  Since the viewers
                          cannot see the characters there, they will not be able to see you
                          insert a new character on the end of the line when you do coarse
                          scrolling (see explanation of Bits 0-2 above).

                          Setting this bit to 1 enables the normal 40-column display, while
                          resetting it to 0 changes the display to 38 columns.  This is a purely
                          cosmetic aid, and it is not necessary to change the screen to the
                          smaller size to use the scrolling feature.

                          Bit 4.  This bit selects multicolor graphics.  The effect of setting
                          this bit to 1 depends on whether or not the bitmap graphics mode is
                          also enabled.

                          If you are not in bitmap mode, and you select multicolor text
                          character mode by setting this bit to 1, characters with a color
                          nybble whose value is less than 8 are displayed normally.  There will
                          be one background color and one foreground color.  But each dot of a
                          character with a color nybble whose value is over 7 can have any one
                          of four different colors.

                          The two colors in the Background Control Registers 1 and 2 (53282-3,
                          $D022-3) are available in addition to the colors supplied by the Color
                          RAM.  The price of these extra colors is a reduction in horizontal
                          resolution.  Instead of each bit controlling one dot, in multicolor
                          mode a pair of bits control the color of a larger dot.  A pattern of
                          11 will light it with the color from the lower three bits of color
                          RAM.  Patterns of 01 and 10 will select the colors from Background
                          Color Registers 1 and 2, respectively, for the double-width dot.

                          You can see the effect that setting this bit has by typing in the
                          following BASIC command line:

                              POKE 53270,PEEK(53280)OR16:PRINT CHR$(149)"THIS IS MULTICOLOR MODE"

                          It is obvious from this example that the normal set of text characters
                          was not made to be used in multicolor mode.  In order to take
                          advantage of this mode, you will need to design custom four-color
                          characters.  For more information, see the alternate entry for 53248
                          ($D000), the Character Generator ROM.

                          If the multicolor and bitmap enable bits are both set to 1, the result
                          is a multicolor bitmap mode.  As in multicolor text mode, pairs of
                          graphics data bits are used to set each dot in a 4 by 8 matrix to one
                          of four colors.  This results in a reduction of the horizontal
                          resolution to 160 double-wide dots across.  But while text multicolor
                          mode allows only one of the four colors to be set individually for
                          each 4 by 8 dot area, bitmap multicolor mode allows up to three
                          different colors to be individually selected in each 4 by 8 dot area.
                          The source of the dot color for each bit-pair combination is shown
                          below:

                          00 Background Color Register 0 (53281, $D021)
                          01 Upper four bits of Video Matrix
                          10 Lower four bits of Video Matrix
                          11 Color RAM nybble (area starts at 55296 ($D800))

                          The fact that bit-pairs are used in this mode changes the strategy for
                          plotting somewhat.  In order to find the byte BY in which the desired
                          bit-pair resides, you must multiply the horizontal position X, which
                          has a value of 0- 159, by 2, and then use the same formula as for
                          hi-res bitmap mode.

                          Given that the horizontal position (0-159) of the dot is stored in the
                          variable X, its vertical position is in the variable Y, and the base
                          address of the bitmap area is in the variable BASE, you can find the
                          desired byte with the formula:

                          BY=BASE+(Y AND 248)*40+(Y AND 7)+(2*X AND 504)

                          Setting the desired bit-pair will depend on what color you chose.
                          First, you must set up an array of bit masks.

                          CA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64

                          To turn on the desired dot, select a color CO from 0 to 3
                          (representing the color selected by the corresponding bit pattern) and
                          execute the following statement:

                          BI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR (CO*CA(BI))

                          The following program will demonstrate this technique:

                              10 CA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64:REM ARRAY FOR BIT PAIRS
                              20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
                              30 POKE53265,PEEK(53265)OR32:POKE53270,PEEK(53270)OR16:REM MULTI-COLOR BIT      MAP
                              40 A$="":FOR I=1 TO 37:A$=A$+"C":NEXT:PRINT CHR$(19);
                              50 FOR I=1 TO 27:PRINT A$;:NEXT:POKE 2023,PEEK(2022): REM SET COLOR MAP
                              60 A$="":FOR I=1 TO 128:A$=A$+"@":NEXT:FOR I=32 TO 63 STEP 2
                              70 POKE648,I:PRINTCHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLR HI-RES SCREEN
                              80 FOR CO=1TO3:FOR Y=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE      BOTTOM
                              90 X=INT(10*CO+15*SIN(CO*45+Y/10)): REM SINE WAVE SHAPE
                              100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X*2 AND 504): REM FIND HI-RES BYTE
                              110 BI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR(CO*CA(BI))
                              120 NEXT Y,CO
                              130 GOTO 130: REM LET IT STAY ON SCREEN

                          Bit 5:  Bit 5 controls the VIC-II chip Reset line.  Setting this bit
                          to 1 will completely stop the video chip from operating.  On older
                          64s, the screen will go black.  It should always be set to 0 to insure
                          normal operation of the chip.

                          Bits 6 and 7.  These bits are not used.

$D017        YXPAND       Sprite Vertical Expansion Register

                     0    Expand Sprite 0 vertically (1=double height, 0=normal height)
                     1    Expand Sprite 1 vertically (1=double height, 0=normal height)
                     2    Expand Sprite 2 vertically (1=double height, 0=normal height)
                     3    Expand Sprite 3 vertically (1=double height, 0=normal height)
                     4    Expand Sprite 4 vertically (1=double height, 0=normal height)
                     5    Expand Sprite 5 vertically (1=double height, 0=normal height)
                     6    Expand Sprite 6 vertically (1=double height, 0=normal height)
                     7    Expand Sprite 7 vertically (1=double height, 0=normal height)

                          This register can be used to double the height of any sprite.  When
                          the bit in this register that corresponds to a particular sprite is
                          set to 1, each dot of the 24 by 21 sprite dot matrix will become two
                          raster scan lines high instead of one.

$D018        VMCSB        VIC-II Chip Memory Control Register

                     0    Unused
                     1-3  Text character dot-data base address within VIC-II address
                            space
                     4-7  Video matrix base address within VIC-II address space

                          This register affects virtually all graphics operations.  It
                          determines the vase address of two very important data areas, the
                          Video Matrix, and the Character Dot-Data area.

                          Bits 1-3.  These bits are used to set the location of the Character
                          Dot-Data area.  This area is where the data is stored (for more
                          information on character shape data, see the alternate entry for
                          location 53248 ($D000), the Character Generator ROM).

                          Bits 1-3 can represent any even number from 0 to 14.  That number
                          stands for the even 1K offset of the character data area from the
                          beginning of VIC-II memory.  For example, if these bits are all set to
                          0, it means that the character memory occupies the first 2K of VIC-II
                          memory.  If they equal 2, the data area starts 2*1K (2*1024) or 2048
                          bytes from the beginning of VIC memory.

                          The default value of this nybble is 4.  This sets the address of the
                          Character Dot-Data area to 4096 ($1000), which is the starting address
                          of where the VIC-II chip addresses the Character ROM.  The normal
                          character set which contains uppercase and graphics occupies the first
                          2K of that ROM.  The alternate character set which contains both
                          upper- and lowercase letters use the second 2K.  Therefore, to shift
                          to the alternate character set, you must change the value of this
                          nybble to 6, with a POKE 53272,PEEK(53272)OR2.  To change it back,
                          POKE 53272,PEEK(53272)AND253.

                          In bitmap mode, the lower nybble controls the location of the bitmap
                          screen data.  Since this data area can start only at an offset of 0 or
                          8K from the beginning of VIC-II memory, only Bit 3 of the Memory
                          Control Register is significant in bitmap mode.  If Bit 3 holds a 0,
                          the offset is 0, and if it holds a 1, the offset is 8192 (8K).

                          Bits 4-7.  This nybble determines the starting address of the Video
                          Matrix area.  This is the 1024-byte area of memory which contains the
                          screen codes for the text characters that are displayed on the screen.
                          In addition, the last eight bytes of this area are used as pointers
                          which designate which 64- byte block of VIC-II memory will be used as
                          shape data for each sprite.

                          These four bits can represent numbers from 0 to 15.  These numbers
                          stand for the offset (in 1K increments) from the beginning of VIC-II
                          memory to the Video Matrix.

                          For example, the default bit pattern is 0001.  This indicates that the
                          Video Matrix is offset by 1K from the beginning of VIC-II memory, the
                          normal starting place for screen memory.  Remember, though, the bit
                          value of this number will be 16 times what the bit pattern indicates,
                          because we are dealing with Bits 4-7.  Therefore, the 0001 in the
                          upper nybble has a value of 16.

                          Using this register, we can move the start of screen memory to any 1K
                          boundary within the 16K VIC-II memory area.  Just changing this
                          register, however, is not enough if you want to use the BASIC line
                          editor.  The editor looks to location 648 ($288) to determine where to
                          print screen characters.

                          If you just change the location of the Video Matrix without changing
                          the value in 648, BASIC will continue to print characters in the
                          memory area starting at 1024, even though that area is no longer being
                          displayed.  The result is that you will not be able to see anything
                          that you type in on the keyboard.  To fix this, you must POKE 648 with
                          the page number of the starting address of screen memory (page
                          number=location/256).  Remember, the actual starting address of screen
                          memory depends not only on the offset from the beginning of VIC-II
                          memory in the register, but also on which bank of 16K is used for
                          VIC-II memory.

                          For example, if the screen area starts 1024 bytes from the beginning
                          of VIC- II memory, and the video chip is using Bank 2 (32768-49151),
                          the actual starting address of screen memory is 32768+1024=33792
                          ($8400).  For examples of how to change the video memory area, and of
                          how to relocate the screen, see the entry for 56576 ($DD00).

$D019        VICIRQ       VIC Interrupt Flag Register

                     0    Flag:  Is the Raster Compare a possible source of an IRQ?
                            (1=yes)
                     1    Flag:  Is a collision between a sprite and the normal graphics
                            display a possible source of an IRQ?  (1=yes)
                     2    Flag:  Is a collision between two sprites a possible source of
                            an IRQ?  (1=yes)
                     3    Flag:  Is the light pen trigger a possible source of an IRQ?
                            (1=yes)
                     4-6  Not used
                     7    Flag:  Is there any VIC-II chip IRQ source which could cause
                            an IRQ?  (1=yes)

                          The VIC-II chip is capable of generating a maskable request (IRQ) when
                          certain conditions relating to the video display are fulfilled.
                          Briefly, the conditions that can cause a VIC-II chip IRQ are:

                          1.  The line number of the current screen line being scanned by the
                          raster is the same as the line number value written to the Raster
                          Register (53266, $D012).

                          2.  A sprite is positioned at the same location where normal graphics
                          data are being displayed.

                          3.  Two sprites are positioned so that they are touching.

                          4.  The light sensor on the light pen has been struck by the raster
                          beam, causing the fire button switch on joystick Control Port #1 to
                          close (pressing the joystick fire button can have the same effect).

                          When one of these conditions is met, the corresponding bit in this
                          status register is set to 1 and latched.  That means that as long as
                          the corresponding enable bit in the VIC IRQ Mask register is set to 1,
                          and IRQ requested will be generated, and any subsequent fulfillment of
                          the same condition will be ignored until the latch is cleared.

                          This allows you to preserve multiple interrupt requests if more than
                          one of the interrupt conditions is met at a time.  In order to keep an
                          IRQ source from generating another request after it has been serviced,
                          and to enable subsequent interrupt conditions to be detected, the
                          interrupt service routine must write a 1 to the corresponding bit.
                          This will clear the latch for that bit.  The default value written to
                          this register is 15, which clears all interrupts.

                          There is only 1 IRQ vector that points to the address of the routine
                          that will be executed when an IRQ interrupt occurs.  The same routine
                          will therefore be executed regardless of the source of the interrupt.
                          This status register provides a method for that routine to check what
                          the source of the IRQ was, so that the routine can take appropriate
                          action.  First, the routine can check Bit 7.  Anytime that any of the
                          other bits in the status register is set to 1, Bit 7 will also be set.
                          Therefore, if that bit holds a 1, you know that the VIC-II chip
                          requested an IRQ (the two CIA chips which are the other sources of IRQ
                          interrupts can be checked in a similar manner).  Once it has been
                          determined that the VIC chip is responsible for the IRQ, the
                          individual bits can be tested to see which of the IRQ conditions have
                          been met.

                          For more information, and a sample VIC IRQ program, see the following
                          entry.

$D01A        IRQMASK      IRQ Mask Register

                     0    Enable Raster Compare IRQ (1=interrupt enabled)
                     1    Enable IRQ to occur when sprite collides with display of
                            normal graphics data (1=interrupt enabled)
                     2    Enable IRQ to occur when two sprites collide (1=interrupt
                            enabled)
                     3    Enable light pen to trigger an IRQ (1=interrupt enabled)
                     4-7  Not used

                          This register is used to enable an IRQ request to occur when one of
                          the VIC-II chip interrupt conditions is met.  In order to understand
                          what that means, and how these interrupts can extend the range of
                          options available to a programmer, you must first understand what an
                          interrupt is.

                          An interrupt is a signal given to the microprocessor (the brains of
                          the computer) that tells it to stop executing its machine language
                          program (for example, BASIC), and to work on another program for a
                          short time, perhaps only a fraction of a second.  After finishing the
                          interrupt program, the computer goes back to executing the main
                          program, just as if there had never been a detour.

                          Bit 0.  This bit enables the Raster Compare IRQ.  The conditions for
                          this IRQ are met when the raster scan reaches the video line indicated
                          by the value written to the Raster Register at 53266 ($D012) and Bit 7
                          of 53265 ($D011).  Again, an explanation of the terminology is in
                          order.

                          In the normal TV display, a beam of electrons (raster) scans the
                          screen, starting in the top-left corner, and moving in a straight line
                          to the right, lighting up appropriate parts of the screen line on the
                          way.  When it comes to the right edge, the beam moves down a line, and
                          starts again from the left.  There are 262 such line that are scanned
                          by the 64 display, 200 of which form the visible screen area.  This
                          scan updates the complete screen display 60 times every second.

                          The VIC-II chip keeps track of which line is being scanned, and stores
                          the scan number in the Raster Register at 53266 and 53265 ($D012 and
                          $D011).  The Raster Register has two functions.  When read, it tells
                          what line is presently being scanned.  But when written to, it
                          designates a particular scan line as the place where a raster
                          interrupt will occur.

                          At the exact moment that the raster beam line number equals the number
                          written to the register, Bit 0 of the status register will be set to
                          1, showing that the conditions for a Raster Compare Interrupt have
                          been fulfilled.  If the raster interrupt is enabled then,
                          simultaneously, the interrupt program will be executed.  This allows
                          the user to reset any of the VIC-II registers at any point in the
                          display, and thus change character sets, background color, or graphics
                          mode for only a part of the screen display.

                          The interrupt routine will first check if the desired condition is the
                          source of the interrupt (see above entry) and then make the changes to
                          the screen display.  Once you have written this interrupt routine, you
                          must take the following steps to install it.

                          1.  Set the interrupt disable flag in the status register with an SEI
                          instruction.  This will disable all interrupts and prevent th system
                          from crashing while you are changing the interrupt vectors.

                          2.  Enable the raster interrupt.  This is done by setting Bit 0 of the
                          VIC- II chip interrupt enable register at location 53274 ($D01A) to 1.

                          3.  Indicate the scan line on which you want the interrupt to occur by
                          writing to the raster registers.  Don't forget that this is a nine-bit
                          value, and you must set both the low byte (in location 53266 ($D012))
                          and the high bit (in the register at 53265 ($D011)) in order to insure
                          that the interrupt will start at the scan line you want it to, and not
                          256 lines earlier or later.

                          4.  Let the computer know where the machine language routine that you
                          want the interrupt to execute starts.  This is done by placing the
                          address in the interrupt vector at locations 788-789 ($314-$315).
                          This address is split into two parts, a low byte and a high byte, with
                          the low byte stored at 788.

                          To calculate the two values for a given address AD, you may use the
                          formula HIBYTE=INT(AD/156) and LOWBYTE=AD-(HIBYTE*256).  The value
                          LOWBYTE would go into location 788, and the value HIBYTE would go into
                          location 789.

                          5.  Reenable interrupts with a CLI instruction, which clears the
                          interrupt disable flag on the status register.

                          When the computer is first turned on, the interrupt vector is set to
                          point to the normal hardware timer interrupt routine, the one that
                          advances the jiffy clock and reads the keyboard.  Since this interrupt
                          routine uses the same vector as the raster interrupt routine, it is
                          best to turn off the hardware timer interrupt by putting a value of
                          127 in location 56333 ($DC0D).

                          If you want the keyboard and jiffy clock to function normally while
                          your interrupt is enabled, you must preserve the contents of locations
                          788 and 789 before you change them to point to your new routine.  Then
                          you must have your interrupt routine jump to the old interrupt routine
                          exactly once per screen refresh (every 1/60 second).

                          Another thing that you should keep in mind is that at least two raster
                          interrupts are required if you want to change only a part of the
                          screen.  Not only must the interrupt routine change the display, but
                          it must also set up another raster interrupt that will change it back.

                          The sample program below uses a raster-scan interrupt to divide the
                          display into three sections.  The first 80 scan lines are in
                          high-resolution bitmap mode, the next 40 are regular text, and the
                          last 80 are in multicolor bitmap mode.  The screen will split this way
                          as soon as a SYS to the routine that turns on the interrupt occurs.
                          The display will stay split even after the program ends.  Only if you
                          hit the STOP and RESTORE keys together will the display return to
                          normal.

                          The interrupt uses a table of values that are POKEd into four key
                          locations during each of the three interrupts, as well as values to
                          determine at what scan lines the interrupt will occur.  The locations
                          affected are Control Register 1 (53265, $D011), Control Register 2
                          (53270, $D016), the Memory Control Register (53272, $D018), and
                          Background Color 0 (53281, $D021).  The data for the interrupt routine
                          is contained in lines 49152-49276.  Each of these line numbers
                          corresponds to the locations where the first data byte in the
                          statement is POKEd into memory.

                          If you look at lines 49264-49276 of the BASIC program, you will see
                          REMark statements that explain which VIC-II registers are affected by
                          the DATA statements in each line.  The number in these DATA
                          statements appear in the reverse order in which they are put into the
                          VIC register.  For example, line 49273 holds the data that will go
                          into Control Register 2.  The last number, 8, is the one that will be
                          placed into Control Register 2 while the top part of the screen is
                          displayed.  The first number, 24, is placed into Control Register 2
                          during the bottom part of the screen display, and changes that portion
                          of the display to multicolor mode.

                          The only tricky part in determining which data byte affects which
                          interrupt comes in line 49264, which holds the data that determines
                          the scan line at which each interrupt will occur.  Each DATA statement
                          entry reflects the scan line at which the next interrupt will occur.
                          The first item in line 49264 is 49.  Even though this is the entry for
                          the third interrupt, the next to be generates is the first interrupt,
                          which occurs at the top of the screen.  Likewise, the last data item
                          of 129 is used during the first interrupt to start the next interrupt
                          at scan line 129.

                          Try experimenting with these values to see what results you come up
                          with.  For example, if you change the number 170 to 210, you will
                          increase the text area by five lines (40 scan lines).

                          By changing the values in the data tables, you can alter the effect of
                          each interrupt.  Change the 20 in line 49276 to 22, and you will get
                          lowercase text in the middle of the screen.  Change the first 8 in
                          line 49273 to 24, and you'll get multicolor text in the center window.
                          Each of these table items may be used exactly like you would use the
                          corresponding register, in order to change background color, to obtain
                          text or bitmap graphics, regular or multicolor modes, screen blanking
                          or extended background color mode.

                          It is even possible to change the table values during a program, by
                          POKEing the new value into the memory location where those table
                          values are stored.  In that way, you can, for example, change the
                          background color of any of the screen parts while the program is
                          running.

                              5 FOR I=0 TO 7:BI(I)=2^I:NEXT
                              10 FOR I=49152 TO 49278:READ A:POKE I,A:NEXT:SYS12*4096
                              20 PRINT CHR$(147):FOR I=0 TO 8:PRINT:NEXT
                              30 PRINT"THE TOP AREA IS HIGH-RES BIT MAP MODE"
                              40 PRINT:PRINT"THE MIDDLE AREA IS ORDINARY TEXT "
                              50 PRINT:PRINT"THE BOTTOM AREA IS MULTI-COLOR BIT MAP"
                              60 FORG=1384 TO 1423:POKE G,6:NEXT
                              70 FORG=1024 TO 1383:POKEG,114:POKE G+640,234:NEXT
                              80 A$="":FOR I=1 TO 128:A$=A$+"@":NEXT:FOR I=32 TO 63 STEP 2
                              90 POKE 648,I:PRINT CHR$(19)CHR$(153);A$;A$;A$;A$:NEXT:POKE 648,4
                              100 BASE=2*4096:BK=49267
                              110 H=40:C=0:FORX=0TO319:GOSUB150:NEXT
                              120 H=160:C=0:FORX=0TO319STEP2:GOSUB150:NEXT:C=40
                              125 FORX=1TO319STEP2:GOSUB150:NEXT
                              130 C=80:FOR X=0 TO 319 STEP2:W=0:GOSUB150:W=1:GOSUB150:NEXT
                              140 GOTO 140
                              150 Y=INT(H+20*SIN(X/10+C)):BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504)
                              160 POKE BY,PEEK(BY) OR (BI(ABS(7-(XAND7)-W))):RETURN
                              49152 DATA 120, 169, 127, 141, 13, 220
                              49158 DATA 169, 1, 141, 26, 208, 169
                              49164 DATA 3, 133, 251, 173, 112, 192
                              49170 DATA 141, 18, 208, 169, 24, 141
                              49176 DATA 17, 208, 173, 20, 3, 141
                              49182 DATA 110, 192, 173, 21, 3, 141
                              49188 DATA 111, 192, 169, 50, 141, 20
                              49194 DATA 3, 169, 192, 141, 21, 3
                              49200 DATA 88, 96, 173, 25, 208, 141
                              49206 DATA 25, 208, 41, 1, 240, 43
                              49212 DATA 190, 251, 16, 4, 169, 2
                              49218 DATA 133, 251, 166, 251, 189, 115
                              49224 DATA 192, 141, 33, 208, 189, 118
                              49230 DATA 192, 141, 17, 208, 189, 121
                              49236 DATA 192, 141, 22, 208, 189, 124
                              49242 DATA 192, 141, 24, 208, 189, 112
                              49248 DATA 192, 141, 18, 208, 138, 240
                              49254 DATA 6, 104, 168, 104, 170, 104
                              49260 DATA 64, 76, 49, 234
                              49264 DATA 49, 170, 129 :REM SCAN LINES
                              49267 DATA 0, 6, 0:REM BACKGROUND COLOR
                              49270 DATA 59, 27,59:REM CONTROL REG. 1
                              49273 DATA 24, 8, 8:REM CONTROL REG. 2
                              49276 DATA 24, 20, 24:REM MEMORY CONTROLRUN

                          Besides enabling the creation of mixed graphics-modes screens, the
                          Raster Compare Interrupt is also useful for creating scrolling zones,
                          so that some parts of the screen can be fine-scrolled while the rest
                          remains stationary.

                          Bit 1 enables the light pen interrupt.  This interrupt can occur when
                          the light of the raster beam strikes the light-sensitive device in the
                          pen's tip, causing it to close the fire button switch on joystick
                          Controller Port #1.

                          The light pen interrupt affords a method of signaling to a program
                          that the pen is being held to the screen, and that its position can be
                          read.  Some light pens provide a push-button switch which grounds one
                          of the other lines on the joystick port.  This switch can be pressed
                          by the user as an additional signal that the pen is properly
                          positioned.  Its location can then be read in the light pen position
                          registers (53267-8, $D013-4).

                          Bit 2 enables the sprite-foreground collision interrupt.  This
                          interrupt can occur if one of the sprite character's dots is touching
                          one of the dots from the foreground display of either text character
                          or bitmap graphics.

                          Bit 3 enables the sprite-sprite collision interrupt, which can occur
                          if one of the sprite character's dots is touching one of the dots of
                          another sprite character.

                          These two interrupts are useful for games, where such collisions often
                          require that some action be taken immediately.  Once the interrupt
                          signals that a collision has occurred, the interrupt routine can check
                          the Sprite- Foreground Collision Register at 53279 ($D01F), or the
                          Sprite-Sprite Collision Register at 53278 ($D01E), to see which sprite
                          or sprites are involved in the collision.  See the entry for those
                          locations for more details on collisions.

$D01B        SPBGPR       Sprite to Foreground Display Priority Register

                     0    Select display priority of Sprite 0 to foreground (0=sprite
                            appears in front of foreground)
                     1    Select display priority of Sprite 1 to foreground (0=sprite
                            appears in front of foreground)
                     2    Select display priority of Sprite 2 to foreground (0=sprite
                            appears in front of foreground)
                     3    Select display priority of Sprite 3 to foreground (0=sprite
                            appears in front of foreground)
                     4    Select display priority of Sprite 4 to foreground (0=sprite
                            appears in front of foreground)
                     5    Select display priority of Sprite 5 to foreground (0=sprite
                            appears in front of foreground)
                     6    Select display priority of Sprite 6 to foreground (0=sprite
                            appears in front of foreground)
                     7    Select display priority of Sprite 7 to foreground (0=sprite
                            appears in front of foreground)

                          If a sprite is positioned to appear at a spot on the screen that is
                          already occupied by text or bitmap graphics, a conflict arises.  The
                          contents of this register determines which one will be displayed in
                          such a situation.  If the bit that corresponds to a particular sprite
                          is set to 0, the sprite will be displayed in front of the foreground
                          graphics data.  If that bit is set to 1, the foreground data will be
                          displayed in front of the sprite.  The default value that this
                          register is set to at power-on is 0, so all sprites start out with
                          priority over foreground graphics.

                          Note that for the purpose of priority, the 01 bit-pair of multicolor
                          graphics modes is considered to display a background color, and
                          therefore will be shown behind sprite graphics even if the foreground
                          graphics data takes priority.  Also, between the sprites themselves
                          there is a fixed priority.  Each sprite has priority over all
                          higher-number sprites, so that Sprite 0 is displayed in front of all
                          the others.

                          The use of priority can aid in creating three-dimensional effects, by
                          allowing some objects on the screen to pass in front of or behind
                          other objects.

$D01C        SPMC         Sprite Multicolor Registers

                     0    Select multicolor mode for Sprite 0 (1=multicolor, 0=hi-res)
                     1    Select multicolor mode for Sprite 1 (1=multicolor, 0=hi-res)
                     2    Select multicolor mode for Sprite 2 (1=multicolor, 0=hi-res)
                     3    Select multicolor mode for Sprite 3 (1=multicolor, 0=hi-res)
                     4    Select multicolor mode for Sprite 4 (1=multicolor, 0=hi-res)
                     5    Select multicolor mode for Sprite 5 (1=multicolor, 0=hi-res)
                     6    Select multicolor mode for Sprite 6 (1=multicolor, 0=hi-res)
                     7    Select multicolor mode for Sprite 7 (1=multicolor, 0=hi-res)

                          Sprite multicolor mode is very similar to text and bitmap multicolor
                          modes (see Bit 4 of 53270, $D016).  Normally, the color of each dot of
                          the sprite is controlled by a single bit of sprite shape data.  When
                          the mode is enabled for a sprite, by setting the corresponding bit of
                          this register to 1, the bits of sprite shape data are grouped together
                          in pairs, with each pair of bits controlling a double-wide dot of the
                          sprite display.  By sacrificing some of the horizontal resolution (the
                          sprite, although the same size, is now only 12 dots wide), you gain
                          the use of two additional colors.  The four possible combinations of
                          these bit-pairs display dot colors from the following sources:

			  |    |					     |
			  |----|---------------------------------------------|
                          | 00 | Background Color Register 0 (transparent)   |
                          | 01 | Sprite Multicolor Register 0 (53285, $D025) |
                          | 10 | Sprite Color Registers (53287-94, $D027-E)  |
                          | 11 | Sprite Multicolor Register 1 (53286, $D026) |

                          Like multicolor text characters, multicolor sprites all share two
                          color registers.  While each sprite can display three foreground
                          colors, only one of these colors in unique to that sprite.  The number
                          of unique colors may be increased by combining more than one sprite
                          into a single character.

$D01D        XXPAND       Sprite Horizontal Expansion Register

                     0    Expand Sprite 0 horizontally (1=double-width sprite, 0=normal width)
                     1    Expand Sprite 1 horizontally (1=double-width sprite, 0=normal width)
                     2    Expand Sprite 2 horizontally (1=double-width sprite, 0=normal width)
                     3    Expand Sprite 3 horizontally (1=double-width sprite, 0=normal width)
                     4    Expand Sprite 4 horizontally (1=double-width sprite, 0=normal width)
                     5    Expand Sprite 5 horizontally (1=double-width sprite, 0=normal width)
                     6    Expand Sprite 6 horizontally (1=double-width sprite, 0=normal width)
                     7    Expand Sprite 7 horizontally (1=double-width sprite, 0=normal width)

                          This register can be used to double the width of any sprite.  Setting
                          any bit of this register to 1 will cause each dot of the corresponding
                          sprite shape to be displayed twice as wide as normal, so that without
                          changing its horizontal resolution, the sprite takes up twice as much
                          space.  The horizontal expansion feature can be used alone, or in
                          combination with the vertical expansion register at 53271 ($D017).

$D01E-$D01F               Sprite Collision Detection Registers

                          While Bit 2 of the VIC IRQ Register at 53273 ($D019) is set to 1
                          anytime two sprites overlap, and Bit 1 is set to 1, when a sprite
                          shape is touching the foreground text or bit-graphics display, these
                          registers specify which sprites were involved in the collision.  Every
                          bit that is set to 1 indicates that the corresponding sprite was
                          involved in the collision.  Reading these registers clears them so
                          that they can detect the next collision.  Therefore, if you plan to
                          make multiple tests on the values stored here, it may be necessary to
                          copy it to a RAM variable for further reference.

                          Note that while these registers tell you what sprites were involved in
                          a collision, they do not necessarily tell you what objects have
                          collided with each other.  It is quite possible to have three sprites
                          lined up in a row, where Sprite A is on the left, Sprite B is in the
                          middle, touching Sprite A, and Sprite C is on the right, touching
                          Sprite B but not touching Sprite A.  The Sprite-Sprite Collision
                          register would show that all three are involved.  The only way to make
                          absolutely certain which collided with which is to check the position
                          of each sprite, and calculate for each sprite display line if a sprite
                          of that size would touch either of the others.  As you can imagine,
                          this is no easy task.

                          There are a few simple rules concerning what does or does not cause a
                          collision.  Though the sprite character consists of 504 dots in a 24
                          by 21 matrix, does which represent data bits that are equal to 0 (or
                          multicolor bit- pairs equal to 00), and therefore always displayed in
                          the background color, do not count when it comes to collision.

                          A collision can occur only if a dot which represents a sprite shape
                          data bit of 1 touches another dot of nonzero graphics data.  Consider
                          the case of two invisible sprites.  The first sprite is enabled, its
                          color set to contrast the background, and it is positioned on the
                          screen, but its shape data bytes are all 0.  This sprite can never be
                          involved in a collision, because it displays no nonzero data.  The
                          second sprite is enabled, positioned on the screen, and its shape
                          pointer set for a data read that is filled with bytes having a value
                          of 255.  Even if that sprite's color is set to the same value as the
                          background color, making the sprite invisible, it can still be
                          involved in collisions.  The only exception to this rule is the 01
                          bit-pair of multicolor graphics data.  This bit-pair is considered
                          part of the background, and the dot it displays can never be involved
                          in a collision.

                          The other rule to remember about collisions is that they can occur in
                          areas that are covered by the screen border.  Collision between
                          sprites can occur when the sprites are offscreen, and collisions
                          between sprites and foreground display data can occur when that data
                          is in an area that is covered by the border due to the reduction of
                          the display to 38 columns or 24 rows.

$D01E        SPSPCL       Sprite to Sprite Collision Register

                     0    Did Sprite 0 collide with another sprite?  (1=yes)
                     1    Did Sprite 1 collide with another sprite?  (1=yes)
                     2    Did Sprite 2 collide with another sprite?  (1=yes)
                     3    Did Sprite 3 collide with another sprite?  (1=yes)
                     4    Did Sprite 4 collide with another sprite?  (1=yes)
                     5    Did Sprite 5 collide with another sprite?  (1=yes)
                     6    Did Sprite 6 collide with another sprite?  (1=yes)
                     7    Did Sprite 7 collide with another sprite?  (1=yes)

$D01F        SPBGCL       Sprite to Foreground Collision Register

                     0    Did Sprite 0 collide with the foreground display?  (1=yes)
                     1    Did Sprite 1 collide with the foreground display?  (1=yes)
                     2    Did Sprite 2 collide with the foreground display?  (1=yes)
                     3    Did Sprite 3 collide with the foreground display?  (1=yes)
                     4    Did Sprite 4 collide with the foreground display?  (1=yes)
                     5    Did Sprite 5 collide with the foreground display?  (1=yes)
                     6    Did Sprite 6 collide with the foreground display?  (1=yes)
                     7    Did Sprite 7 collide with the foreground display?  (1=yes)

$D020-$D02E               VIC-II Color Register

                          Although these color registers are used for various purposes, all of
                          them have one thing in common.  Like the Color RAM Nybbles, only the
                          lower four bits are connected.  Therefore, when reading these
                          registers, you must mask out the upper four bits (that is,
                          BORDERCOLOR=PEEK(53280)AND15) in order to get a true reading.

$D020        EXTCOL       Border Color Register

                          The color value here determines the color of the border or frame
                          around the central display area.  The entire screen is set to this
                          color when the blanking feature of Bit 4 of 53265 ($D011) is enabled.
                          The default color value is 14 (light blue).

$D021        BGCOL0       Background Color 0

                          This register sets the background color for all text modes, sprite
                          graphics, and multicolor bitmap graphics.  The default color value is
                          6 (blue).

$D022        BGCOL1       Background Color 1

                          This register sets the color for the 01 bit-pair of multicolor
                          character graphics, and the background color for characters having
                          screen codes 64-127 in extended background color text mode.  The
                          default color value is 1 (white).

$D023        BGCOL2       Background Color 2

                          This register sets the color for the 10 bit-pair of multicolor
                          character graphics, and the background color for characters having
                          screen codes 128-191 in extended background color text mode.  The
                          default color value is 2 (red).

$D024        BGCOL3       Background Color 3

                          This register sets the background color for characters having screen
                          codes between 192 and 255 in extended background color text mode.  The
                          default color value is 3 (cyan).

$D025        SPMC0        Sprite Multicolor Register 0

                          This register sets the color that is displayed by the 01 bit-pair in
                          multicolor sprite graphics.  The default color value is 4 (purple).

$D026        SPMC1        Sprite Multicolor Register 1

                          This register sets the color that is displayed by the 11 bit-pair in
                          multicolor sprite graphics.  The default color value is 0 (black).

$D027-$D02E               Sprite Color Registers

                          These registers are used to set the color to be displayed by bits of
                          hi-res sprite data having a value of 1, and by bit-pairs of multicolor
                          sprite data having a value of 10.  The color of each sprite is
                          determined by its own individual color register.

$D027        SP0COL       Sprite 0 Color Register (the default color value is 1, white)

$D028        SP1COL       Sprite 1 Color Register (the default color value is 2, red)

$D029        SP2COL       Sprite 2 Color Register (the default color value is 3, cyan)

$D02A        SP3COL       Sprite 3 Color Register (the default color value is 4, purple)

$D02B        SP4COL       Sprite 4 Color Register (the default color value is 5, green)

$D02C        SP5COL       Sprite 5 Color Register (the default color value is 6, blue)

$D02D        SP6COL       Sprite 6 Color Register (the default color value is 7, yellow)

$D02E        SP7COL       Sprite 7 Color Register (the default color value is 12, medium gray)

$D02F-$D03F               Not Connected

                          The VIC-II chip has only 47 registers for 64 bytes of possible address
                          space.  Therefore, the remaining 17 addresses do not access any
                          memory.  When read, they will always give a value of 255 ($FF).  This
                          value will not change after writing to them.

$D040-$D3FF               VIC-II Register Images

                          Since the VIC-II requires only enough addressing lines to handle 64
                          locations (the minimum possible for its 47 registers), none of the
                          higher bits are decoded when addressing this 1K area.  The result is
                          that every 64 byte area in this 1K block is a mirror of every other.
                          POKE53281+64,1 has the same effect as POKE53281,1 or
                          POKE53281+10*64,1; they all turn the screen background to white.  For
                          the sake of clarity in your programs it is advisable to use the base
                          address of the chip.

$D400-$D41C               Sound Interface Device (SID) Registers

                          Memory locations 54272-54300 ($D400-$D41C) are used to address the
                          6581 Sound Interface Device (SID).

                          SID is a custom music synthesizer and sound effects generator chip
                          that gives the 64 its impressive musical capabilities.  It provides
                          three separate music channels, or voices, as they are called.  Each
                          voice has 16-bit frequency resolution, waveform control, envelope
                          shaping, oscillator synchronization, and ring modulation.  In
                          addition, programmable high-pass, low-pass, and band-pass filters can
                          be set and enabled or disabled for each sound channel.

                          Since quite a few of these locations must be used in concert to
                          produce sound, a brief summary of the interplay between some of these
                          registers may be helpful.

                          Often the first step is to select an overall volume level using the
                          Volume Register.  Then, the desired frequency or pitch of the note is
                          chosen by writing to each of the two bytes which make up the 16-bit
                          Frequency Register.

                          An ADSR envelope setting must be chosen by writing values to the
                          Attack/ Decay and Sustain/Release Register.  These determine the rate
                          of the rise and fall of the volume of the note from zero volume to
                          peak volume and back again.  These rates have a great influence on the
                          character of the sound.

                          Finally, the waveform must be selected, and the note started (or the
                          oscillator gated, as we say).  This is done by writing certain bits to
                          the Control Register.  The waveform control lets you select one of
                          four different waveforms, each of which has varying harmonic content
                          that affects the tone quality of the sound.  By writing a 1 to the
                          gate bit, you start the Attack/ Delay/Sustain cycle.  After rising to a
                          peak and declining to the Sustain volume, the volume will continue at
                          the same level until you write a 0 to the gate bit.  Then, the Release
                          cycle will start.  Make sure that you keep the same waveform bit set
                          to 1 while you write the 0 to the gate bit, so that the Release cycle
                          starts.  Otherwise, the sound will stop entirely, as it also will if
                          the Volume Register or the Frequency Register is set to 0.

                          It should be noted that except for the last four SID chip registers,
                          these addresses are write-only.  That means that their values cannot
                          be determined by PEEKing these locations.

$D400-$D401               Voice 1 Frequency Control

                          Together, these two locations control the frequency or pitch of the
                          musical output of voice 1.  Some frequency must be selected in order
                          for voice 1 to be heard.  This frequency may be changed in the middle
                          of a note to achieve special effects.  The 16-bit range of the
                          Frequency Control Register covers over eight full octaves, and allows
                          you to vary the pitch from 0 (very low) to about 4000 Hz (very high),
                          in 65536 steps.  The exact frequency of the output can be determined
                          by the equation

                          FREQUENCY=(REGISTER VALUE*CLOCK/16777216)Hz

                          where CLOCK equals the system clock frequency, 1022730 for American
                          (NTSC) systems, 985250 for European (PAL), and REGISTER VALUE is the
                          combined value of these frequency registers.  That combined value
                          equals the value of the low byte plus 256 times the value of the high
                          byte.  Using the American (NTSC) clock value, the equation works out
                          to

                          FREQUENCY=REGISTER VALUE*.060959458 Hz

$D400        FRELO1       Voice 1 Frequency Control (low byte)

$D401        FREHI1       Voice 1 Frequency Control (high byte)

$D402-$D403               Voice 1 Pulse Waveform Width Control

                          As you will see below under the description of the Control Register at
                          54276 ($D404), you can select one of four different waveforms for the
                          output of each voice.  If the pulse waveform is selected, these
                          registers must be set to establish the pulse width.

                          The pulse width has a 12-bit resolution, being made up of the value in
                          the first register and the value in the lower nybble of the second
                          register.  The pulse width determines the duty cycle, or proportion of
                          the time that the rectangular wave will stay at the high part of the
                          cycle.

                          The following formula shows the relationship between the value in the
                          Pulse Width Register and the proportion of time that the wave stays at
                          the high part of the cycle:

                          PULSE WIDTH=(REGISTER VALUE/40.95)%

                          The possible range of the register values (0-4095) covers the range of
                          the duty cycles from 0 to 100 percent in 4096 steps.  Changing the
                          pulse width will vastly change the sound created with the pulse
                          waveform.

$D402        PWLO1        Voice 1 Pulse Waveform Width (low byte)

$D403        PWHI1        Voice 1 Pulse Waveform Width (high nybble)

$D404        VCREG1       Voice 1 Control Register

                     0    Gate Bit:  1=Start attack/decay/sustain, 0=Start release
                     1    Sync Bit:  1=Synchronize Oscillator with Oscillator 3 frequency
                     2    Ring Modulation:  1=Ring modulate Oscillators 1 and 3
                     3    Test Bit:  1=Disable Oscillator 1
                     4    Select triangle waveform
                     5    Select sawtooth waveform
                     6    Select pulse waveform
                     7    Select random noise waveform

                          Bit 0.  Bit 0 is used to gate the sound.  Setting this bit to a 1
                          while selecting one of the four waveforms will start the
                          attack/decay/sustain part of the cycle.  Setting this bit back to 0
                          (while keeping the same waveform setting) anytime after a note has
                          started playing will begin the release cycle of the note.  Of course,
                          in order for the gate bit to have an effect, the frequency and
                          attack/decay/sustain/release (ADSR) registers must be set, as well as
                          the pulse width, if necessary, and the volume control set to a nonzero
                          value.

                          Bit 1.  This bit is used to synchronize the fundamental frequency of
                          Oscillator 1 with the fundamental frequency of Oscillator 3, allowing
                          you to create a wide range of complex harmonic structures from voice
                          1.  Synchronization occurs when this bit is set to 1.  Oscillator 3
                          must be set to some frequency other than zero, but no other voice 3
                          parameters will affect the output from voice 1.

                          Bit 2.  When Bit 2 is set to 1, the triangle waveform output of voice
                          1 is replaced with a ring modulated combination of Oscillators 1 and
                          3.  This ring modulation produces nonharmonic overtone structures that
                          are useful for creating bell or gong effects.

                          Bit 3.  Bit 3 is the test bit.  When set to 1, it disables the output
                          of the oscillator.  This can be useful in generating very complex
                          waveforms (even speech synthesis) under software control.

                          Bit 4.  When set to 1, Bit 4 selects the triangle waveform output of
                          Oscillator 1.  Bit 0 must also be set for the note to be sounded.

                          Bit 5.  This bit selects the sawtooth waveform when set to 1.  Bit 0
                          must also be set for the sound to begin.

                          Bit 6.  Bit 6 chooses the pulse waveform when set to 1.  The harmonic
                          content of sound produced using this waveform may be varied using the
                          Pulse Width Registers.  Bit 0 must be set to begin the sound.

                          Bit 7.  When Bit 7 is set to 1, the noise output waveform for
                          Oscillator 1 is set.  This creates a random sound output whose
                          waveform varies with a frequency proportionate to that of Oscillator
                          1.  It can be used to imitate the sound of explosions, drums, and
                          other unpitched noises.

                          One of the four waveforms must be chosen in order to create a sound.
                          Setting more than one of these bits will result in a logical ANDing of
                          the waveforms.  Particularly, the combination of the noise waveform
                          and another is not recommended.

$D405-$D406               Voice 1 Envelope (ADSR) Control

                          When a note is played on a musical instrument, the volume does not
                          suddenly rise to a peak and then cut off to zero.  Rather, the volume
                          builds to a peak, levels off to an intermediate value, and then fades
                          away.  This creates what is known as a volume envelope.

                          The first phase of the envelope, in which the volume builds to a peak,
                          is known as the attack phase.  The second, in which it declines to an
                          intermediate level, is called the decay phase.  The third, in which
                          the intermediate level of volume is held, is known as the sustain
                          period.  The final interval, in which the sound fades away, is called
                          the release part of the cycle.

                          The SID chip allows the volume envelope of each voice to be
                          controlled, so that specific instruments may be imitated, or new
                          sounds created.  This is done via the attack/decay and sustain/release
                          registers.  Each register devotes four bits (which can store a number
                          from 0 to 15) to each phase of the cycle.  When a note is gated by
                          writing a 1 to a waveform bit and to Bit 0 of the Control Register,
                          the attack cycle begins.

                          The volume of the sound builds to a peak over the period of time
                          specified by the high nybble of the attack/decay register.  Once it
                          has reached the peak volume, it falls to the intermediate level during
                          the period indicated by the low nybble of the attack/decay register
                          (this is the decay phase).  The volume of this intermediate or sustain
                          level is selected by placing a value in the high nybble of the
                          sustain/release register.  This volume level is held until a 0 is
                          written to the gate bit of the control register (while leaving the
                          waveform bit set).  When that happens, the release phase begins, and
                          the volume of the sound begins to taper off during the period
                          indicated by the low nybble of the sustain/release register.

                          You may notice the volume of the sound does not quite get to 0 at the
                          end of the release cycle, and you may need to turn off the sound to
                          get rid of the residual noise.  You can do this either by setting the
                          waveform bit back to 0, changing the frequency to 0, or setting the
                          volume to 0.

$D405        ATDCY1       Voice 1 Attack/Decay Register

                     0-3  Select decay cycle duration (0-15)
                     4-7  Select attack cycle duration (0-15)

                          Bits 4-7 control the duration of the attack cycle.  This is the period
                          of time over which the volume will rise from 0 to its peak amplitude.
                          There are 16 durations which may be selected.  The way in which the
                          number placed here corresponds to the elapsed time of this cycle is as
                          follows:

                          0 = 2 milliseconds           8 = 100 milliseconds
                          1 = 8 milliseconds           9 = 250 milliseconds
                          2 = 16 milliseconds         10 = 500 milliseconds
                          3 = 24 milliseconds         11 = 800 milliseconds
                          4 = 38 milliseconds         12 = 1 second
                          5 = 56 milliseconds         13 = 3 seconds
                          6 = 68 milliseconds         14 = 5 seconds
                          7 = 80 milliseconds         15 = 8 seconds

                          Bits 0-3 control the length of the decay phase, in which the volume of
                          the note declines from the peak reached in the attack phase to the
                          sustain level.  The number selected corresponds to the length of this
                          phase as shown below:

                          0 = 6 milliseconds           8 = 300 milliseconds
                          1 = 24 milliseconds          9 = 750 milliseconds
                          2 = 48 milliseconds         10 = 1.5 seconds
                          3 = 72 milliseconds         11 = 2.4 seconds
                          4 = 114 milliseconds        12 = 3 seconds
                          5 = 168 milliseconds        13 = 9 seconds
                          6 = 204 milliseconds        14 = 15 seconds
                          7 = 240 milliseconds        15 = 24 seconds

                          Since the two functions share one register, you must multiply the
                          attack value by 16 and add it to the decay value in order to come up
                          with the number to be placed in the register:

                          REGISTER VALUE=(ATTACK*16)+DECAY

$D406        SUREL1       Voice 1 Sustain/Release Control Register

                     0-3  Select release cycle duration (0-15)
                     4-7  Select sustain volume level (0-15)

                          Bits 4-7 select the volume level at which the note is sustained.
                          Following the decay cycle, the volume of the output of voice 1 will
                          remain at the selected sustain level as long as the gate bit of the
                          Control Register is set to 1.  The sustain values range from 0, which
                          chooses no volume, to 15, which sets the output of voice 1 equal to
                          the peak volume achieved during the attack cycle.

                          Bits 0-3 determine the length of the release cycle.  This phase, in
                          which the volume fades from the sustain level to near zero volume,
                          begins when the gate bit of the Control Register is set to 0 (while
                          leaving the waveform setting that was previously chosen).  The
                          duration of this decline in volume corresponds to the number (0-15)
                          selected in the same way as for the decay value:

                          |    |                  |
                          |----|------------------|
                          |  0 | 6 milliseconds   |
                          |  1 | 24 milliseconds  |
                          |  2 | 48 milliseconds  |
                          |  3 | 72 milliseconds  |
                          |  4 | 114 milliseconds |
                          |  5 | 168 milliseconds |
                          |  6 | 204 milliseconds |
                          |  7 | 240 milliseconds |
                          |  8 | 300 milliseconds |
                          |  9 | 750 milliseconds |
                          | 10 | 1.5 seconds      |
                          | 11 | 2.4 seconds      |
                          | 12 | 3 seconds        |
                          | 13 | 9 seconds        |
                          | 14 | 15 seconds       |
                          | 15 | 24 seconds       |

$D407-$D414               Voice 2 and Voice 3 Controls

                          The various control registers for these two voices correspond almost
                          exactly to those of voice 1.  The one exception is that the sync and
                          ring-modulation bits of voice 2 operate on Oscillators 1 and 2, while
                          the same bits of the Control Register for voice 3 uses Oscillators 2
                          and 3.

$D407        FRELO2       Voice 2 Frequency Control (low byte)

$D408        FREHI2       Voice 2 Frequency Control (high byte)

$D409        PWLO2        Voice 2 Pulse Waveform Width (low byte)

$D40A        PWHI2        Voice 2 Pulse Waveform Width (high nybble)

$D40B        VCREG2       Voice 2 Control Register

                     0    Gate Bit:  1=Start attack/decay/sustain, 0=Start release
                     1    Sync Bit:  1=Synchronize oscillator with Oscillator 1 frequency
                     2    Ring Modulation:  1=Ring modulate Oscillators 2 and 1
                     3    Test Bit:  1=Disable Oscillator 2
                     4    Select triangle waveform
                     5    Select sawtooth waveform
                     6    Select pulse waveform
                     7    Select noise waveform

$D40C        ATDCY2       Voice 2 Attack/Decay Register

                     0-3  Select decay cycle duration (0-15)
                     4-7  Select attack cycle duration (0-15)

$D40D        SUREL2       Voice 2 Sustain/Release Control Register

                     0-3  Select release cycle duration (0-15)
                     4-7  Select sustain volume level (0-15)

$D40E        FRELO3       Voice 3 Frequency Control (low byte)

$D40F        FREHI3       Voice 3 Frequency Control (high byte)

$D410        PWLO3        Voice 3 Pulse Waveform Width (low byte)

$D411        PWHI3        Voice 3 Pulse Waveform Width (high nybble)

$D412        VCREG3       Voice 3 Control Register

                     0    Gate Bit:  1=Start attack/decay/sustain, 0=Start release
                     1    Sync Bit:  1=Synchronize oscillator with Oscillator 2 frequency
                     2    Ring Modulation:  1=Ring modulate Oscillators 3 and 2
                     3    Test Bit:  1=Disable Oscillator 3
                     4    Select triangle waveform
                     5    Select sawtooth waveform
                     6    Select pulse waveform
                     7    Select noise waveform

$D413        ATDCY3       Voice 3 Attack/Decay Register

                     0-3  Select decay cycle duration (0-15)
                     4-7  Select attack cycle duration (0-15)

$D414        SUREL3       Voice 3 Sustain/Release Control Register

                     0-3  Select release cycle duration (0-15)
                     4-7  Select sustain volume level (0-15)

$D415-$D418               Filter Controls

                          In addition to the controls detailed above for each voice, the SID
                          chip also provides a filtering capability which allows you to
                          attenuate (make quieter) certain ranges of frequencies.  Any one or
                          all three voices can be filtered, and there is even a provision for
                          filtering an external signal that is input through pin 5 of the
                          monitor jack.

                          A low-pass filter is available, which suppresses the volume of those
                          frequency components that are above a designated cutoff level.  The
                          high-pass filter reduces the volume of frequency components that are
                          below a certain level.  The band-pass filter reduces the volume of
                          frequency components on both sides of the chosen frequency, thereby
                          enhancing that frequency.  Finally, the high-pass and low-pass filters
                          can be combined to form a notch reject filter, which reduces the
                          volume of the frequency components nearest the selected frequency.
                          These various filters can dramatically change the quality of the sound
                          produced.

                          The first two registers are used to select the filter cutoff
                          frequency.  This is the frequency above or below which any sounds will
                          be made quieter.  The further away from this level any frequency
                          components are, the more their output volume will be suppressed (high-
                          and low-pass filters reduce the volume of those components by 12 dB
                          per octave away from the center frequency, while the band-pass filter
                          attenuates them by 6 dB per octave).

                          The cutoff frequency has an 11-bit range (which corresponds to the
                          numbers 0 to 2047).  This is made up of a high-byte and three low
                          bits.  Therefore, to compute the frequency represented by the value in
                          these registers, you must multiply the value in the high byte by 8,
                          and add the value of the low three bits.  The range of cutoff
                          frequencies represented by these 2048 values stretches from 30 Hz to
                          about 12,000 Hz.  The exact frequency may be calculated with the
                          formula:

                          FREQUENCY=(REGISTER VALUE*5.8)+30Hz

                          An additional element in filtering is the resonance control.  This
                          allows you to peak the volume of the frequency elements nearest the
                          cutoff frequency.

$D415        CUTLO
                     0-2  Low portion of filter cutoff frequency
                     5-7  Unused

$D416        CUTHI        Filter Cutoff Frequency (high byte)

$D417        RESON        Filter Resonance Control Register

                     0    Filter the output of voice 1?  1=yes
                     1    Filter the output of voice 2?  1=yes
                     2    Filter the output of voice 3?  1=yes
                     3    Filter the output from the external input?  1=yes
                     4-7  Select filter resonance 0-15

                          Bits 0-3 are used to control which of the voices will be altered by
                          the filters.  If one of these bits is set to 1, the corresponding
                          voice will be processed through the filter, and its harmonic content
                          will be changed accordingly.  If the bit is set to 0, the voice will
                          pass directly to the audio output.  Note that there is also a
                          provision for processing an external audio signal which is brought
                          through pin 5 of the Audio/Video Port.

                          Bits 4-7 control the resonance of the filter.  By placing a number
                          from 0 to 15 in these four bits, you may peak the volume of those
                          frequencies nearest the cutoff.  This creates an even sharper
                          filtering effect.  A setting of 0 causes no resonance, while a setting
                          of 15 gives maximum resonance.

$D418        SIGVOL       Volume and Filter Select Register

                     0-3  Select output volume (0-15)
                     4    Select low-pass filter, 1=low-pass on
                     5    Select band-pass filter, 1=band-pass on
                     6    Select high-pass filter, 1=high-pass on
                     7    Disconnect output of voice 4, 1=voice 3 off

                          Bits 0-3 control the volume of all outputs.  The possible volume
                          levels range from 0 (no volume) to 15 (maximum volume).  Some level of
                          volume must be set here before any sound can be heard.

                          Bits 4-6 control the selection of the low-pass, band-pass, or
                          high-pass filter.  A 1 in any of these bits turns the corresponding
                          filter on.  These filters can be combined, although only one cutoff
                          frequency can be chosen.  In order for the filter to have any effect,
                          at least one of the voices must be routed through it using the Filter
                          Resonance Control Register at 54295 ($D417).

                          When Bit 7 is set to 1,  it disconnects the output of voice 3.  This
                          allows you to use the output of the oscillator for modulating the
                          frequency of the other voices, or for generating random number,
                          without any undesired audio output.

$D419-$D41A               Game Paddle Inputs

                          These registers allow you to read the game paddles that plug into
                          joystick Controller Ports 1 and 2.  Each paddle uses a variable
                          resistor (also known as a potentiometer or pot), whose resistance is
                          controlled by turning a knob.  The varying resistance is used to vary
                          the voltage to two pins of the SID chip between 0 and +5 volts.
                          Analog-to-digital (A/D) converters in the chip interpret these voltage
                          levels as binary values and store the values in these registers.
                          These registers return a number from 0 (minimum resistance) to 255
                          (maximum resistance) for each paddle in either of the ports, depending
                          on the position of the paddle knob.

                          Since these registers will read the paddle values for only one
                          controller port, there is a switching mechanism which allows you to
                          select which of the two ports to read.  By writing a bit-pair of 01
                          (bit value of 64) to the last two bits of CIA #1 Data Port A (56320,
                          $DC00), you select the paddles on joystick Controller Port 1.  By
                          writing a bit-pair of 10 (bit value of 128), you select the paddles on
                          Controller Port 2.

                          If you look at the description of Data Port A (56320, $DC00), however,
                          you will notice that it is also used in the keyboard scanning process.
                          By writing to this port, you determine which keyboard column will be
                          read.

                          Since the IRQ interrupt keyboard scan routine and the routine that
                          checks for the STOP key are putting values into this location 60 times
                          per second, you cannot reliable select the pair of paddles you wish to
                          read from BASIC without first turning off the keyboard IRQ.  This can
                          be done with a POKE 56333,127.  You can then read the paddles with the
                          statements A=PEEK(54297) and B=PEEK(54298).  The IRQ can be restored
                          after a paddle read with a POKE 56333,129.  It may, however, be easier
                          and more accurate in the long run to use a machine language paddle
                          read subroutine such as that presented on page 347 of the Commodore 64
                          Programmer's Reference Guide.

                          The paddle fire buttons are read as Bits 2 and 3 of the Data Ports A
                          (56320, $DC00) and B (56321, $DC01).  On Port A, if Bit 2 is set to 0,
                          button 1 is pushed, and if Bit 3 is set to 0, button 2 is pushed.  On
                          Port B, if Bit 2 is set to 0, button 3 is pushed, and if Bit 3 is set
                          to 0, button 4 is pushed.

                          The BASIC statements to test these buttons, therefore, are:

                              PB(1)=(PEEK(56321)AND4)/4
                              PB(2)=(PEEK(56321)AND8)/8
                              PB(3)=(PEEK(56320)AND4)/4
                              PB(4)=(PEEK(56320)AND8)/8

                          If a 0 is returned by the PEEK statement, the button is pushed, and if
                          a 1 is returned, it is not.

$D419        POTX         Read Game Paddle 1 (or 3) Position

$D41A        POTY         Read Game Paddle 2 (or 4) Position

$D41B        RANDOM       Read Oscillator 3/Random Number Generator

                          This register lets you read the upper eight bits of the waveform
                          output of Oscillator 3.  The kinds of numbers generated by this output
                          depend on the type of waveform selected.

                          If the sawtooth waveform is chosen, the output read by this register
                          will be a series of numbers which start at 0 and increase by 1 to a
                          maximum of 255, at which time they start over at 0.

                          When the triangle waveform is chosen, they increase from 0 to 255, at
                          which time they decrease to 0 again.  The rate at which these numbers
                          change is determined by the frequency of Oscillator 3.

                          If the pulse waveform is selected, the output here will be either 255
                          or 0.

                          Finally, selecting the noise waveform will produce a random series of
                          numbers between 0 and 255.  This allows you to use the register as a
                          random number generator for games.

                          There are many other uses for reading Oscillator 3, however,
                          particularly for modulation of the other voices through machine
                          language software.  For example, the output of this register could be
                          added to the frequency of another voice.  If the triangle waveform
                          were selected for this purpose, it would cause the frequency of the
                          other voice to rise and fall, at the frequency of Oscillator 3
                          (perhaps for vibrato effects).  This output can also be combined with
                          the Filter Frequency or Pulse Width Registers to vary the values in
                          these registers quickly over a short period of time.

                          Normally, when using Oscillator 3 for modulation, the audio output of
                          voice 3 should be turned off by setting Bit 7 of the Volume and Filter
                          Select Register at 54296 ($d418) to 1.  It is not necessary to gate
                          Bit 0 of Control Register 3 to use the oscillator, however, as its
                          output is not affected by the ADSR envelope cycle.

$D41C        ENV3         Envelope Generator 3 Output

                          This register allows you to read the output of the voice 3 Envelope
                          generator, in much the same way that the preceding register lets you
                          read the output of Oscillator 3.  This output can also be added to
                          another oscillator's Frequency Control Registers, Pulse Width
                          Registers, or the Filter Frequency Control Register.  In order to
                          produce any output from this register, however, the gate bit in
                          Control Register 3 must be set to 1.  Just as in the production of
                          sound, setting the gate bit to 1 starts the attack/decay/sustain
                          cycle, and setting it back to 0 starts the release cycle.

$D41D-$D41F               Not Connected

                          The SID chip has been provided with enough addresses for 32 different
                          registers, but as it has only 29, the remaining three addresses are
                          not used.  Reading them will always return a value of 255 ($FF), and
                          writing to them will have no effect.

$D420-$D7FF               SID Register Images

                          Since the SID chip requires enough addressing lines for only 32
                          locations (the minimum possible for its 29 registers), none of the
                          higher bits are decoded when addressing the 1K area that has been
                          assigned to it.  The result is that every 32-byte area in this 1K
                          block is a mirror of every other.  For the sake of clarity in your
                          programs, it is advisable not to use these addresses at all.

$D800-$DBFF               Color RAM

                          The normal Commodore 64 text graphics system uses a screen RAM area to
                          keep track of the character shapes that are to be displayed.  But
                          since each character can be displayed in any of 16 foreground colors,
                          there must also be a parallel area which keeps track of the foreground
                          color.  This 1024-byte area is used for that purpose (actually, since
                          there are only 1000 screen positions, only 1000 byte actually affect
                          screen color).

                          These 1000 bytes each control the foreground color of one character,
                          with the first byte controlling the foreground color of the character
                          in the upper- left corner, and subsequent bytes controlling the
                          characters to the right and below that character.

                          Because only four bits are needed to represent the 16 colors
                          available, only the low four bits of each Color RAM location are
                          connected (this is why they are sometimes referred to as Color RAM
                          Nybbles).  Writing to the high bits will not affect them, and these
                          four bits will usually return a random value when read (a small number
                          of 64s return a constant value).

                          Therefore, in order to read Color RAM correctly, you must mask out the
                          top bits by using the logical AND function.  In BASIC, you can read
                          the first byte of Color RAM with the statement CR=PEEK(55296)AND15.
                          This will always return a color value between 0 and 15.  These color
                          values correspond to the following colors:

                          |   |                         |
                          |---|-------------------------|
                          | 0 | BLACK		   |
                          | 1 | WHITE		   |
                          | 2 | RED			   |
                          | 3 | CYAN (LIGHT BLUE-GREEN) |
                          | 4 | PURPLE		   |
                          | 5 | GREEN		   |
                          | 6 | BLUE			   |
                          | 7 | YELLOW		   |
                          | 8 | ORANGE		   |
                          | 9 | BROWN		   |
                          |10 | LIGHT RED		   |
                          |11 | DARK GRAY		   |
                          |12 | MEDIUM GRAY		   |
                          |13 | LIGHT GREEN		   |
                          |14 | LIGHT BLUE		   |
                          |15 | LIGHT GRAY		   |

                          Color mapping affords a convenient method of changing the color of the
                          text display without changing the letters.  By POKEing the appropriate
                          section of Color RAM, you can change the color of a whole section of
                          text on the screen without affecting the content of the text.  You can
                          even use this method to make letters disappear by changing their
                          foreground colors to match the background (or by changing the
                          background to match the foreground), and later make them reappear by
                          changing them back, or by changing the background to a contrasting
                          color.  An interesting example program which changes Color RAM quickly
                          in BASIC can be found under the entry for 648 ($288).

                          A change in the Operating System causes newer 64s to set all of the
                          Color RAM locations to the same value as the current background color
                          whenever the screen is cleared.  Therefore, POKEing character codes to
                          the Screen RAM area will not appear to have any effect, because the
                          letters will be the same color as the background.  This can easily be
                          turned to your advantage, however, because it means that all you have
                          to do to set all of Color RAM to a particular value is to set the
                          background color to that value (using the register at 53281 ($D021)),
                          clear the screen, and return the background color in the desired
                          value.

                          The various graphics modes use this area differently than does the
                          regular text mode.  In high-resolution bitmap mode, this area is not
                          used at all, but in multicolor bitmap mode it is used to determine the
                          color of the 11 bit-pair for a given 8 by 8 dot area.

                          In multicolor text mode, only the lowest three bits are used, so only
                          colors 0-7 may be selected.  The fourth bit is used to determine
                          whether a character will be displayed in regular text or multicolor
                          text.  Characters with a color value over 7 are displayed as
                          multicolor characters, with the color of the 11 bit-pair determined by
                          the color value minus 8.  Characters with a color value under 8 are
                          displayed normally.

                          It should be noted that unlike the Screen RAM area, which can be moved
                          to any RAM location, the Color RAM area is fixed, and will function
                          normally regardless of where screen memory is located.

$DC00-$DC0F               Complex Interface Adapter (CIA) #1 Registers

                          Locations 56320-56335 ($DC00-$DC0F) are used to communicate with the
                          Complex Interface Adapter chip #1 (CIA #1).  This chip is a successor
                          to the earlier VIA and PIA devices used on the VIC-20 and PET.  This
                          chip functions the same way as the VIA and PIA:  It allows the 6510
                          microprocessor to communicate with peripheral input and output
                          devices.  The specific devices that CIA #1 reads data from and sends
                          data to are the joystick controllers, the paddle fire buttons, and the
                          keyboard.

                          In addition to its two data ports, CIA #1 has two timers, each of
                          which can count an interval from a millionth of a second to a
                          fifteenth of a second.  Or the timers can be hooked together to count
                          much longer intervals.  CIA #1 has an interrupt line which is
                          connected to the 6510 IRQ line.  These two timers can be used to
                          generate interrupts at specified intervals (such as the 1/60 second
                          interrupt used for keyboard scanning, or the more complexly timed
                          interrupts that drive the tape read and write routines).  As you will
                          see below, the CIA chip has a host of other features to aid in
                          Input/Output functions.

$DC00-$DC01               CIA #1 Data Ports A and B

                          These registers are where the actual communication with outside
                          devices takes place.  Bits of data written to these registers can be
                          sent to external devices, while bits of data that those devices send
                          can be read here.

                          The keyboard is so necessary to the computer's operation that you may
                          have a hard time thinking of it as a peripheral device.  Nonetheless,
                          it cannot be directly read by the 6510 microprocessor.  Instead, the
                          keys are connected in a matrix of eight rows by eight columns to CIA
                          #1 Ports A and B.  The layout of this matrix is shown below.

                              WRITE TO PORT A               READ PORT B (56321, $DC01)
                              56320/$DC00
                                       Bit 7   Bit 6   Bit 5   Bit 4   Bit 3   Bit 2   Bit 1   Bit 0

                              Bit 7    STOP    Q       C=      SPACE   2       CTRL    <-      1

                              Bit 6    /       ^       =       RSHIFT  HOME    ;       *       LIRA

                              Bit 5    ,       @       :       .       -       L       P       +

                              Bit 4    N       O       K       M       0       J       I       9

                              Bit 3    V       U       H       B       8       G       Y       7

                              Bit 2    X       T       F       C       6       D       R       5

                              Bit 1    LSHIFT  E       S       Z       4       A       W       3

                              Bit 0    CRSR DN F5      F3      F1      F7      CRSR RT RETURN  DELETE

                          As you can see, there are two keys which do not appear in the matrix.
                          The SHIFT LOCK key is not read as a separate key, but rather is a
                          mechanical device which holds the left SHIFT key switch in a closed
                          position.  The RESTORE key is not read like the other keys either.  It
                          is directly connected to the NMI interrupt line of the 6510
                          microprocessor, and causes an NMI interrupt to occur whenever it is
                          pressed (not just when it is pressed with the STOP key).

                          In order to read the individual keys in the matrix, you must first set
                          Port A for all outputs (255, $FF), and Port B for all inputs (0),
                          using the Data Direction Registers.  Note that this is the default
                          condition.  Next, you must write a 0 in the bit of Data Port A that
                          corresponds to the column that you wish to read, and a 1 to the bits
                          that correspond to columns you wish to ignore.  You will then be able
                          to read Data Port B to see which keys in that column are being pushed.

                          A 0 in any bit position signifies that the key in the corresponding
                          row of the selected column is being pressed, while a 1 indicates that
                          the key is not being pressed.  A value of 255 ($FF) means that no keys
                          in that column are being pressed.

                          Fortunately for us all, an interrupt routine causes the keyboard to be
                          read, and the results are made available to the Operating System
                          automatically every 1/60 second.  And even when the normal interrupt
                          routine cannot be used, you can use the Kernal SCNKEY routine at 65439
                          ($FF9F) to read the keyboard.

                          These same data ports are also used to read the joystick controllers.
                          Although common sense might lead you to believe that you could read
                          the joystick that is plugged into the port marked Controller Port 1
                          from Data Port A, and the second joystick from Data Port B, there is
                          nothing common about the Commodore 64.  Controller Port 1 is read from
                          Data Port B, and Controller Port 2 is read from CIA #1 Data Port A.

                          Joysticks consist of five switches, one each for up, down, right, and
                          left directions, and another for the fire button.  The switches are
                          read like the key switches--if the switch is pressed, the
                          corresponding bit will read 0, and if it is not pressed, the bit will
                          be set to 1.  From BASIC, you can PEEK the ports and use the AND and
                          NOT operators to mask the unused bits and inverse the logic for easier
                          comprehension.  For example, to read the joystick in Controller Port
                          1, you could use the statement:

                          S1=NOT PEEK(56321)AND15

                          The meaning of the possible numbers returned are:

                          |    |              |
                          |----|--------------|
                          |  0 | none pressed |
                          |  1 | up		 |
                          |  2 | down	 |
                          |  4 | left	 |
                          |  5 | up left	 |
                          |  6 | down left	 |
                          |  8 | right	 |
                          |  9 | up right	 |
                          | 10 | down right	 |

                          The same technique can be used for joystick 2, by substituting 56320
                          as the number to PEEK.  By the way, the 3 and 7 aren't listed because
                          they represent impossible combinations like up-down.

                          To read the fire buttons, you can PEEK the appropriate port and use
                          the AND operator to mask all but bit 4:

                              T1=(PEEK(56321)AND16)/16

                          The above will return a 0 if the button is pressed, and a 1 if it is
                          not.  Substitute location 56320 as the location to PEEK for Trigger
                          Button 2.

                          Since CIA #1 Data Port B is used for reading the keyboard as well as
                          joystick 1, some confusion can result.  The routine that checks the
                          keyboard has no way of telling whether a particular bit was set to 0
                          by a keypress or one of the joystick switches.  For example, if you
                          plug the joystick into Controller Port 1 and push the stick to the
                          right, the routine will interpret this as the 2 key being pressed,
                          because both set the same bit to 0.  Likewise, when you read the
                          joystick, it will register as being pushed to the right if the 2 key
                          is being pressed.

                          The problem of mistaking the keyboard for the joystick can be solved
                          by turning off the keyscan momentarily when reading the stick with a
                          POKE 56333, 127:POKE 56320,255, and restoring it after the read with a
                          POKE 56333,129.  Sometimes you can use the simpler solution of
                          clearing the keyboard buffer after reading the joystick, with a POKE
                          198,0.

                          The problem of mistaking the joystick for a keypress is much more
                          difficult--there is no real way to turn off the joystick.  Many
                          commercially available games just use Controller Port 2 to avoid the
                          conflict.  So, if you can't beat them, sit back and press your
                          joystick to the left in order to slow down a program listing (the
                          keyscan routine thinks that it is the CTRL key).

                          As if all of the above were not enough, Port A is also used to control
                          which set of paddles is read by the SID chip, and to read the paddle
                          fire buttons.  Since there are two paddles per joystick Controller
                          Port, and only two SID registers for reading paddle positions, there
                          has to be a method for switching the paddle read from joystick Port 1
                          to joystick Port 2.

                          When Bit 7 of Port A is set to 1 and Bit 6 is cleared to 0, the SID
                          registers will read the paddles on Port 1.  When Bit 7 is set to 0 and
                          Bit 6 is set to 1, the paddles on Port 2 are read by the SID chip
                          registers.  Note that this also conflicts with the keyscan routine,
                          which is constantly writing different values to CIA #1 Data Port A in
                          order to select the keyboard column to read (most of the time, the
                          value for the last column is written to this port, which coincides
                          with the selection of paddles on joystick Port 1).  Therefore, in
                          order to get an accurate reading, you must turn off the keyscan IRQ
                          and select which joystick port you want to read.  See POTX at 54297
                          ($D419), which is the SID register where the paddles are read, for the
                          exact technique.

                          Although the SID chip is used to read the paddle settings, the fire
                          buttons are read at CIA #1 Data Ports A and B.  The fire buttons for
                          the paddles plugged into Controller Port 1 are read at Data Port B
                          (56321, $DC01), while those for the paddles plugged into Controller
                          Port 2 are read from Data Port A (56320, $DC00).  The fire buttons are
                          read at Bit 2 and Bit 3 of each port (the same as the joystick left
                          and joystick right switches), and as usual, the bit will read 0 if the
                          corresponding button is pushed, and 1 if it is not.

                          Although only two of the rout paddle values can be read at any one
                          time, you can always read all four paddle buttons.  See the game
                          paddle input description at 54297 ($D419) for the BASIC statements
                          used to read these buttons.

                          Finally, Data Port B can also be used as an output by either Timer A
                          or B.  It is possible to set a mode in which the timers do not cause
                          an interrupt when they run down (see the descriptions of Control
                          Registers A and B at 56334-5 ($DC0E-F)).  Instead, they cause the
                          output on Bit 6 or 7 of Data Port B to change.  Timer A can be set
                          either to pulse the output of Bit 6 for one machine cycle, or to
                          toggle that bit from 1 to 0 or 0 to 1.  Timer B can use Bit 7 of this
                          register for the same purpose.

$DC00        CIAPRA       Data Port Register A

                     0    Select to read keyboard column 0.
                          Read joystick 2 up direction
                     1    Select to read keyboard column 1.
                          Read joystick 2 down direction
                     2    Select to read keyboard column 2.
                          Read joystick 2 left direction.
                          Read paddle 1 fire button
                     3    Select to read keyboard column 3.
                          Read joystick 2 right direction.
                          Read paddle 2 fire button
                     4    Select to read keyboard column 4.
                          Read joystick 2 fire button
                     5    Select to read keyboard column 5
                     6    Select to read keyboard column 6.
                          Select to read paddles on Port A or B
                     7    Select to read keyboard column 7.
                          Select to read paddles on Port A or B

$DC01        CIAPRB       Data Port Register B

                     0    Read keyboard row 0.
                          Read joystick 1 up direction
                     1    Read keyboard row 1.
                          Read joystick 1 down direction
                     2    Read keyboard row 2.
                          Read joystick 1 left direction.
                          Read paddle 1 fire button
                     3    Read keyboard row 3.
                          Read joystick 1 right direction.
                          Read paddle 2 fire button
                     4    Read keyboard row 4.
                          Read joystick 1 fire button
                     5    Read keyboard row 5
                     6    Read keyboard row 6.
                          Toggle or pulse data output for Timer A
                     7    Read keyboard row 7.
                          Toggle or pulse data output for Timer B

$DC02-$DC03               CIA #1 Data Direction Registers A and B

                          These Data Direction Registers control the direction of data flow over
                          Data Ports A and B.  Each bit controls the direction of the data on
                          the corresponding bit of the port.  If the bit of the Direction
                          Register is set to a 1, the corresponding Data Port bit will be used
                          for data output.  If the bit is set to a 0, the corresponding Data
                          Port bit will be used for data input.  For example, Bit 7 of Data
                          Direction Register A controls Bit 7 of Data Port A, and if that
                          direction bit is set to 0, Bit 7 of Data Port A will be used for data
                          input.  If the direction bit is set to 1, however, data Bit 7 on Port
                          A will be used for data output.

                          The default setting for Data Direction Register A is 255 (all
                          outputs), and for Data Direction Register B it is 0 (all inputs).
                          This corresponds to the setting used when reading the keyboard (the
                          keyboard column number is written to Data Port A, and the row number
                          is then read in Data Port B).

$DC02        CIDDRA       Data Direction Register A

                     0    Select Bit 0 of Data Port A for input or output (0=input, 1=output)
                     1    Select Bit 1 of Data Port A for input or output (0=input, 1=output)
                     2    Select Bit 2 of Data Port A for input or output (0=input, 1=output)
                     3    Select Bit 3 of Data Port A for input or output (0=input, 1=output)
                     4    Select Bit 4 of Data Port A for input or output (0=input, 1=output)
                     5    Select Bit 5 of Data Port A for input or output (0=input, 1=output)
                     6    Select Bit 6 of Data Port A for input or output (0=input, 1=output)
                     7    Select Bit 7 of Data Port A for input or output (0=input, 1=output)

$DC03        CIDDRB       Data Direction Register B

                     0    Select Bit 0 of Data Port B for input or output (0=input, 1=output)
                     1    Select Bit 1 of Data Port B for input or output (0=input, 1=output)
                     2    Select Bit 2 of Data Port B for input or output (0=input, 1=output)
                     3    Select Bit 3 of Data Port B for input or output (0=input, 1=output)
                     4    Select Bit 4 of Data Port B for input or output (0=input, 1=output)
                     5    Select Bit 5 of Data Port B for input or output (0=input, 1=output)
                     6    Select Bit 6 of Data Port B for input or output (0=input, 1=output)
                     7    Select Bit 7 of Data Port B for input or output (0=input, 1=output)

$DC04-$DC07               Timers A and B Low and High Bytes

                          These four timer registers (two for each timer) have different
                          functions depending on whether you are reading from them or writing to
                          them.  When you read from these registers, you get the present value
                          of the Timer Counter (which counts down from its initial value to 0).
                          When you write data to these registers, it is stored in the Timer
                          Latch, and from there it can be used to load the Timer Counter using
                          the Force Load bit of Control Register A or B (see 56334-5 ($DC0E-F)
                          below).

                          These interval timers can hold a 16-bit number from 0 to 65535, in
                          normal 6510 low-byte, high-byte format (VALUE=LOW BYTE+256*HIGH BYTE).
                          Once the Timer Counter is set to an initial value, and the timer is
                          started, the timer will count down one number every microprocessor
                          clock cycle.  Since the clock speed of the 64 (using the American NTSC
                          television standard) is 1,022,730 cycles per second, every count takes
                          approximately a millionth of a second.  The formula for calculating
                          the amount of time it will take for the timer to count down from its
                          latch value to 0 is:

                          TIME=LATCH VALUE/CLOCK SPEED

                          where LATCH VALUE is the value written to the low and high timer
                          registers (LATCH VALUE=TIMER LOW+256*TIMER HIGH), and CLOCK SPEED is
                          1,022,370 cycles per second for American (NTSC) standard television
                          monitors, or 985,250 for European (PAL) monitors.

                          When Timer Counter A or B gets to 0, it will set Bit 0 or 1 in the
                          Interrupt Control Register at 56333 ($DC0D).  If the timer interrupt
                          has been enabled (see 56333 ($DC0D)), an IRQ will take place, and the
                          high bit of the Interrupt Control Register will be set to 1.
                          Alternately, if the Port B output bit is set, the timer will write
                          data to Bit 6 or 7 of Port B.  After the timer gets to 0, it will
                          reload the Timer Latch Value, and either stop or count down again,
                          depending on whether it is in one-shot or continuous mode (determined
                          by Bit 3 of the Control Register).

                          Although usually a timer will be used to count the microprocessor
                          cycles, Timer A can count either the microprocessor clock cycles or
                          external pulses on the CTN line, which is connected to pin 4 of the
                          User Port.

                          Timer B is even more versatile.  In addition to these two sources,
                          Timer B can count the number of times that Timer A goes to 0.  By
                          setting Timer A to count the microprocessor clock, and setting Timer B
                          to count the number of times that Timer A zeros, you effectively link
                          the two timers into one 32-bit timer that can count up to 70 minutes
                          with accuracy within 1/15 second.

                          In the 64, CIA #1 Timer A is used to generate the interrupt which
                          drives the routine for reading the keyboard and updating the software
                          clock.  Both Timers A and B are also used for the timing of the
                          routines that read and write tape data.  Normally, Timer A is set for
                          continuous operation, and latched with a value of 149 in the low byte
                          and 66 in the high byte, for a total Latch Value of 17045.  This means
                          that it is set to count to 0 every 17045/1022730 seconds, or
                          approximately 1/60 second.

                          For tape reads and writes, the tape routines take over the IRQ
                          vectors.  Even though the tape write routines use the on-chip I/O port
                          at location 1 for the actual data output to the cassette, reading and
                          writing to the cassette uses both CIA #1 Timer A and Timer B for
                          timing the I/O routines.

$DC04        TIMALO       Timer A (low byte)

$DC05        TIMAHI       Timer A (high byte)

$DC06        TIMBLO       Timer B (low byte)

$DC07        TIMBHI       Timer B (high byte)

$DC08-$DC0B               Time of Day Clock (TOD)

                          In addition to the two general-purpose timers, the 6526 CIA chip has a
                          special-purpose Time of Day Clock, which keeps time in a format that
                          humans can understand a little more easily than microseconds.

                          This Time of Day Clock even has an alarm, which can cause an interrupt
                          at a specific time.  It is organized in four registers, one each for
                          hours, minutes, seconds, and tenths of seconds.  Each register reads
                          out in Binary Coded Decimal (BCD) format, for easier conversion to
                          ASCII digits.  A BCD byte is divided into two nybbles, each of which
                          represents a single digit in base 10.  Even though a four-bit nybble
                          can hold a number from 0 to 15, only the base 10 digits of 0-9 are
                          used.  Therefore, 10 0'clock would be represented by a byte in the
                          hours register with the nybbles 0001 and 0000, which stand for the
                          digits 1 and 0.  The binary value of this byte would be 16 (16 times
                          the high nybble plus the low nybble).  Each of the other registers
                          operates in the same manner.  In addition, Bit 7 of the hours register
                          is used as an AM/PM flag.  If that bit is set to 1, it indicates PM,
                          and if it is set to 0, the time is AM.

                          The Time of Day Clock Registers can be used for two purposes,
                          depending on whether you are reading them or writing to them.  If you
                          are reading them, you will always be reading the time.  There is a
                          latching feature associated with reading the hours register in order
                          to solve the problem of the time changing while you are reading the
                          registers.  For example, if you were reading the hours register just
                          as the time was changing from 10:59 to 11:00, it is possible that you
                          would read the 10 in the hours register, and by the time you read the
                          minutes register it would have changed from 59 to 00.  Therefore, you
                          would read 10:00 instead of either 10:59 or 11:00.

                          To prevent this kind of mistake, the Time of Day Clock Registers stop
                          updating as soon as you read the hours register, and do not start
                          again until you read the tenths of seconds register.  Of course, the
                          clock continues to keep time internally even though it does not update
                          the registers.  If you want to read only minutes, or seconds or tenths
                          of seconds, there is no problem, and no latching will occur.  But
                          anytime you read hours, you must follow it by reading tenths of
                          seconds, even if you don't care about them, or else the registers will
                          not continue to update.

                          Writing to these registers either sets the time or the alarm,
                          depending on the setting of Bit 7 of Control Register B (56335,
                          $DC0F).  If that bit is set to 1, writing to the Time of Day registers
                          sets the alarm.  If the bit is set to 0, writing to the Time of Day
                          registers sets the Time of Day clock.  In either case, as with reading
                          the registers, there is a latch function.  This function stops the
                          clock from updating when you write to the hours register.  The clock
                          will not start again until you write to the tenths of seconds
                          registers.

                          The only apparent use of the Time of Day Clock by the 64's Operating
                          System is in the BASIC RND statement.  There, the seconds and tenths
                          of seconds registers are read and their values used as part of the
                          seed value for the RND(0) command.

                          Nonetheless, this clock can be an invaluable resource for the 64 user.
                          It will keep time more accurately than the software clock maintained
                          at locations 60-162 ($A0-$A2) by the Timer A interrupt routine.  And
                          unlike that software clock, the Time of Day Clock will not be
                          disturbed when I/O operations disrupt the Timer A IRQ, or when the IRQ
                          vector is diverted elsewhere.  Not even a cold start RESET will
                          disrupt the time.  For game timers, just set the time for 00:00:00:0
                          and it will keep track of elapsed time in hours, minutes, seconds and
                          tenths of seconds format.

                          The following digital clock program, written in BASIC, will
                          demonstrate the use of these timers:

                              10 PRINT CHR$(147):GOSUB 200
                              20 H=PEEK(56331):POKE 1238,(H AND 16)/16+48:POKE 1239,(H AND 15)+48
                              30 M=PEEK(56330):POKE 1241,(M AND 240)/16+48:POKE 1242,(M AND 15)+48
                              40 S=PEEK(56329):POKE 1244,(S AND 240)/16+48:POKE 1245,(S AND 15)+48
                              50 T=PEEK(56328)AND15:POKE 1247,T+48:GOTO 20
                              200 INPUT"WHAT IS THE HOUR";H$:IF H$="" THEN 200
                              210 H=0:IF LEN(H$)>1 THEN H=16
                              220 HH=VAL(RIGHT$(H$,1)):H=H+HH:POKE56331,H
                              230 INPUT "WHAT IS THE MINUTE";M$:IF M$=""THEN 200
                              240 M=0:IF LEN(M$)>1 THEN M=16*VAL(LEFT$(M$,1))
                              250 MM=VAL(RIGHT$(M$,1)):M=M+MM:POKE56330,M
                              260 INPUT "WHAT IS THE SECOND";S$:IF S$=""THEN 200
                              270 S=0:IF LEN(S$)>1 THEN S=16*VAL(LEFT$(S$,1))
                              280 SS=VAL(RIGHT$(S$,1)):S=S+SS:POKE56329,S:POKE56328,0
                              290 POKE 53281,1:PRINT CHR$(147):POKE 53281,6
                              300 POKE 1240,58:POKE 1243,58:POKE 1246,58:GOTO 20

$DC08        TODTEN       Time of Day Clock Tenths of Seconds

                     0-3  Time of Day tenths of second digit (BCD)
                     4-7  Unused

$DC09        TODSEC       Time of Day Clock Seconds

                     0-3  Second digit of Time of Day seconds (BCD)
                     4-6  First digit of Time of Day seconds (BCD)
                     7    Unused

$DC0A        TODMIN       Time of Day Clock Minutes

                     0-3  Second digit of Time of Day minutes (BCD)
                     4-6  First digit of Time of Day minutes (BCD)
                     7    Unused

$DC0B        TODHRS       Time of Day Clock Hours

                     0-3  Second digit of Time of Day hours (BCD)
                     4    First digit of Time of Day hours (BCD)
                     5-6  Unused
                     7    AM/PM Flag (1=PM, 0=AM)

$DC0C        CIASDR       Serial Data Port

                          The CIA chip has an on-chip serial port, which allows you to send or
                          receive a byte of data one bit at a time, with the most significant
                          bit (Bit 7) being transferred first.  Control Register A at 56334
                          ($DC0E) allows you to choose input or output modes.  In input mode, a
                          bit of data is read from the SP line (pin 5 of the User Port) whenever
                          a signal on the CNT line (pin 4) appears to let you know that it is
                          time for a read.  After eight bits are received this way, the data is
                          placed in the Serial Port Register, and an interrupt is generated to
                          let you know that the register should be read.

                          In output mode, you write data to the Serial Port Register, and it is
                          sent out over the SP line (pin 5 of the User Port), using Timer A for
                          the baud rate generator.  Whenever a byte of data is written to this
                          register, transmission will start as long as Timer A is running and in
                          continuous mode.  Data is sent at half the Timer A rage, and an output
                          will appear on the CNT line (pin 4 of the User Port) whenever a bit is
                          sent.  After all eight bits have been sent, an interrupt is generated
                          to indicate that it is time to load the next byte to send into the
                          Serial Register.

                          The Serial Data Register is not used by the 64, which does all of its
                          serial I/O through the regular data ports.

$DC0D        CIAICR       Interrupt Control Register

                     0    Read / did Timer A count down to 0?  (1=yes).
                          Write/ enable or disable Timer A interrupt (1=enable, 0=disable)
                     1    Read / did Timer B count down to 0?  (1=yes).
                          Write/ enable or disable Timer B interrupt (1=enable, 0=disable)
                     2    Read / did Time of Day Clock reach the alarm time?  (1=yes).
                          Write/ enable or disable TOD clock alarm interrupt (1=enable,
                          0=disable)
                     3    Read / did the serial shift register finish a byte? (1=yes).
                          Write/ enable or disable serial shift register interrupt (1=enable,
                          0=disable)
                     4    Read / was a signal sent on the flag line?  (1=yes).
                          Write/ enable or disable FLAG line interrupt (1=enable, 0=disable)
                     5    Not used
                     6    Not used
                     7    Read / did any CIA #1 source cause an interrupt?  (1=yes).
                          Write/ set or clear bits of this register (1=bits written with 1 will
                          be set, 0=bits written with 1 will be cleared)

                          This register is used to control the five interrupt sources on the
                          6526 CIA chip.  These sources are Timer A, Timer B, the Time of Day
                          Clock, the Serial Register, and the FLAG line.  Timers A and B cause
                          an interrupt when they count down to 0.  The Time of Day Clock
                          generates an interrupt when it reaches the ALARM time.  The Serial
                          Shift Register interrupts when it compiles eight bits of input or
                          output.  An external signal pulling the CIA hardware line called FLAG
                          low will also cause an interrupt (on CIA #1, this FLAG line is
                          connected to the Cassette Read line of the Cassette Port).

                          Even if the condition for a particular interrupt is satisfied, the
                          interrupt must still be enabled for an IRQ actually to occur.  This is
                          done by writing to the Interrupt Control Register.  What happens when
                          you write to this register depends on the way that you set Bit 7.  If
                          you set it to 0, any other bit that was written to with a 1 will be
                          cleared, and the corresponding interrupt will be disabled.  If you set
                          Bit 7 to 1, any bit written to with a 1 will be set, and the
                          corresponding interrupt will be enabled.  In either case, the
                          interrupt enable flags for those bits written to with a 0 will not be
                          affected.

                          For example, in order to disable all interrupts from BASIC, you could
                          POKE 56333, 127.  This sets Bit 7 to 0, which clears all of the other
                          bits, since they are all written with 1's.  Don't try this from BASIC
                          immediate mode, as it will turn off Timer A which causes the IRQ for
                          reading the keyboard, so that it will in effect turn off the keyboard.

                          To turn on the Timer A interrupt, a program could POKE 56333,129.  Bit
                          7 is set to 1 and so is Bit 0, so the interrupt which corresponds to
                          Bit 0 (Timer A) is enabled.

                          When you read this register, you can tell if any of the conditions for
                          a CIA Interrupt were satisfied because the corresponding bit will be
                          set to a 1.  For example, if Timer A counts down to 0, Bit 0 of this
                          register will be set to 1.  If, in addition, the mask bit that
                          corresponds to that interrupt source is set to 1, and an interrupt
                          occurs, Bit 7 will also be set.  This allows a multi-interrupt system
                          to read one bit and see if the source of a particular interrupt was
                          CIA #1.  You should note, however, that reading this register clears
                          it, so you should preserve its contents in RAM if you want to test
                          more than one bit.

$DC0E        CIACRA       Control Register A

                     0    Start Timer A (1=start, 0=stop)
                     1    Select Timer A output on Port B (1=Timer A output appears on Bit 6 of
                            Port B)
                     2    Port B output mode (1=toggle Bit 6, 0=pulse Bit 6 for one cycle)
                     3    Timer A run mode (1=one-shot, 0=continuous)
                     4    Force latched value to be loaded to Timer A counter (1=force load
                            strobe)
                     5    Timer A input mode (1=count microprocessor cycles, 0=count signals on
                            CNT line at pin 4 of User Port)
                     6    Serial Port (56332, $DC0C) mode (1=output, 0=input)
                     7    Time of Day Clock frequency (1=50 Hz required on TOD pin, 0=60 Hz)

                          Bits 0-3.  This nybble controls Timer A.  Bit 0 is set to 1 to start
                          the timer counting down, and set to 0 to stop it.  Bit 3 sets the
                          timer for one-shot or continuous mode.

                          In one-shot mode, the timer counts down to 0, sets the counter value
                          back to the latch value, and then sets Bit 0 back to 0 to stop the
                          timer.  In continuous mode, it reloads the latch value and starts all
                          over again.

                          Bits 1 and 2 allow you to send a signal on Bit 6 of Data Port B when
                          the timer counts.  Setting Bit 1 to 1 forces this output (which
                          overrides the Data Direction Register B Bit 6, and the normal Data
                          Port B value).  Bit 2 allows you to choose the form this output to Bit
                          6 of Data Port B will take.  Setting Bit 2 to a value of 1 will cause
                          Bit 6 to toggle to the opposite value when the timer runs down (a
                          value of 1 will change to 0, and a value of 0 will change to 1).
                          Setting Bit 2 to a value of 0 will cause a single pulse of a one
                          machine-cycle duration (about a millionth of a second) to occur.

                          Bit 4.  This bit is used to load the Timer A counter with the value
                          that was previously written to the Timer Low and High Byte Registers.
                          Writing a 1 to this bit will force the load (although there is no data
                          stored here, and the bit has no significance on a read).

                          Bit 5.  Bit 5 is used to control just what it is Timer A is counting.
                          If this bit is set to 1, it counts the microprocessor machine cycles
                          (which occur at the rate of 1,022,730 cycles per second).  If the bit
                          is set to 0, the timer counts pulses on the CNT line, which is
                          connected to pin 4 of the User Port.  This allows you to use the CIA
                          as a frequency counter or an event counter, or to measure pulse width
                          or delay times of external signals.

                          Bit 6.  Whether the Serial Port Register is currently inputting or
                          outputting data (see the entry for that register at 56332 ($DC0C) for
                          more information) is controlled by this bit.

                          Bit 7.  This bit allows you to select from software whether the Time
                          of Day Clock will use a 50 Hz or 60 Hz signal on the TOD pin in order
                          to keep accurate time (the 64 uses a 60 Hz signal on that pin).

$DC0F        CIACRB       Control Register B

                     0    Start Timer B (1=start, 0=stop)
                     1    Select Timer B output on Port B (1=Timer B output appears on
                            Bit 7 of Port B)
                     2    Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one
                            cycle)
                     3    Timer B run mode (1=one-shot, 0=continuous)
                     4    Force latched value to be loaded to Timer B counter (1=force
                            load strobe)
                     5-6  Timer B input mode
                              00 = Timer B counts microprocessor cycles
                              01 = Count signals on CNT line at pin 4 of User Port
                              10 = Count each time that Timer A counts down to 0
                              11 = Count Timer A 0's when CNT pulses are also present
                     7    Select Time of Day write (0=writing to TOD registers sets
                          alarm, 1=writing to TOD registers sets clock)

                          Bits 0-3.  This nybble performs the same functions for Timer B that
                          Bits 0-3 of Control Register A perform for Timer A, except that Timer
                          B output on Data Port B appears at Bit 7, and not Bit 6.

                          Bits 5 and 6.  These two bits are used to select what Timer B counts.
                          If both bits are set to 0, Timer B counts the microprocessor machine
                          cycles (which occur at the rate of 1,022,730 cycles per second).  If
                          Bit 6 is set to 0 and Bit 5 is set to 1, Timer B counts pulses on the
                          CNT line, which is connected to pin 4 of the User Port.  If Bit 6 is
                          set to 1 and Bit 5 is set to 0, Timer B counts Timer A underflow
                          pulses, which is to say that it counts the number of times that Timer
                          A counts down to 0.  This is used to link the two numbers into one
                          32-bit timer that can count up to 70 minutes with accuracy to within
                          1/15 second.  Finally, if both bits are set to 1, Timer B counts the
                          number of times that Timer A counts down to 0 and there is a signal on
                          the CNT line (pin 4 of the User Port).

                          Bit 7.  Bit 7 controls what happens when you write to the Time of Day
                          registers.  If this bit is set to 1, writing to the TOD registers sets
                          the ALARM time.  If this bit is cleared to 0, writing to the TOD
                          registers sets the TOD clock.

$DC10-$DCFF               CIA #1 Register Images

                          Since the CIA chip requires only enough addressing lines to handle 16
                          registers, none of the higher bits are decoded when addressing the
                          256-byte area that has been assigned to it.  The result is that every
                          16-byte area in this 256-byte block is a mirror of every other.  Even
                          so, for the sake of clarity in your programs it is advisable to use
                          the base address of the chip, and not use the higher addresses to
                          communicate with the chip.

$DD00-$DD0F               Complex Interface Adapter (CIA) #2 Registers

                          Locations 56576-56591 ($DD00-$DD0F) are used to address the Complex
                          Interface Adapter chip #2 (CIA #2).  Since the chip itself is
                          identical to CIA #1, which is addressed at 56320 ($DC00), the
                          discussion here will be limited to the use which the 64 makes of this
                          particular chip.  For more general information on the chip registers,
                          please see the corresponding entries for CIA #1.

                          One of the significant differences between CIA chips #1 and #1 is the
                          use to which Data Ports A and B are put.  The peripheral input and
                          output devices that CIA #2 controls are those on the Serial Bus (such
                          as the 1541 Disk Drive and 1525 printer), the RS-232 device (which is
                          used for telecommunications), and the User Port, an eight-bit parallel
                          port that can be turned to whatever purpose the user desires.  In
                          addition, Data Port A has the important task of selecting the 16K bank
                          of memory that will be used by the VIC-II chip for graphics.

                          Another significant difference between CIA chips #1 and #2 is that the
                          interrupt line of CIA #1 is wired to the 6510 IRQ line, while that of
                          CIA #2 is wired to the NMI line.  This means that interrupts from this
                          chip cannot be masked by setting the Interrupt disable flag (SEI).
                          They can be disabled from CIA's Mask Register, though.  Be sure to use
                          the NMI vector when setting up routines to be driven by interrupts
                          generated by this chip.

$DD00-$DD01               CIA #2 Data Ports A and B

                          These registers are where the communication with the Serial Bus,
                          RS-232 device, and User Port take place.  The Serial Bus is like the
                          IEEE bus which is used by the PET, in that it allows more than one
                          device to be connected to the port at a time, in a daisychain
                          arrangement.  Since each byte of data is sent one bit at a time,
                          however, the Serial Bus is at least eight times slower than the IEEE.
                          It is presently used to control the 1541 Disk Drive and 1525 printer,
                          and other devices (such as printer interface for Centronics- type
                          parallel printers and stringy floppy wafer tape storage units) can be
                          placed on this bus.

                          Data Port A is used for communication with the Serial Bus.  Bits 5 and
                          7 are used for Serial Bus Data Output and Input, respectively, and
                          Bits 4 and 6 are used for the Serial Bus Clock Pulse Output and Input.
                          Bit 3 of Data Port A is used to send the ATN signal on the Serial Bus.

                          The 64 has built-in software to handle RS-232 communications through a
                          modem or other device plugged in the RS-232/User Port.  The RS-232
                          device uses Bit 2 of Data Port A for data output (it is the only line
                          from Port A that is connected to the RS-232/User Port jack).  It also
                          makes heavy use of Port B, using Bit 7 for the Data Set Ready (DSR)
                          signal, Bit 6 for the Clear to Send (CTS), Bit 4 for the Carrier
                          Detect (DCD), Bit 3 for the Ring Indicator (RI), Bit 2 for Data
                          Terminal Ready (DTR), Bit 1 for Request to Send (RTS), and Bit 0 for
                          data input.  See locations 659-660 ($293-$294) for more details on the
                          RS-232 device.

                          All of the data lines which the RS-232 device uses are also available
                          to the user as part of the User Port.  All of the Port B data lines,
                          and Bit 2 of Port A, are brought out to the User Port connector on the
                          back of the 64.  These data bits are utilized in the normal way:  The
                          port connections are made to TTL-level input or output devices, and
                          the direction of data is determined by the Data Direction Registers.

                          In addition, the User Port has pins connected to the two CIA Serial
                          Ports (whose eight-bit shift registers are well-suited for
                          serial-to-parallel and parallel-to-serial conversion),and the two CNT
                          lines which aid in the operation of the Serial Ports.  The CNT lines
                          can also be used in conjunction with the CIA Timers, and allow them to
                          be used as frequency counters, event counters, interval timers, etc.
                          The advanced features of the CIA chip make almost any type of
                          interfacing application possible, and in the near future we will
                          probably see many interesting applications for the User Port on the
                          64.  A pin description of the User Port connector is provided below:

                          | User Port Pin | CIA Line | RS-232 DB-25 Pin |      Description				    |
                          |---------------|----------|------------------|--------------------------------     ----------------|
                          | 1             |          |                  |      Ground					    |
                          | 2             |          |                  | +5 Volts (100 milliamps      maximum)		    |
                          | 3             |          |                  | RESET (grounding this pin      causes a cold start) |
                          | 4             | CNT1     |                  | CIA #1 Serial Port and Timer      Counter	    |
                          | 5             | SP1      |                  | CIA #1 Serial Data      Port			    |
                          | 6             | CNT2     |                  | CIA #2 Serial Port and Timer      Counter	    |
                          | 7             | SP2      |                  | CIA #2 Serial Data      Port			    |
                          | 8             | PC2      |                  | CIA #2 handshaking      line			    |
                          | 9             |          |                  | Connected to the ATN line of      the Serial Bus    |
                          | 10            |          |                  | 9 Volts AC (+ phase, 50      milliamps maximum)	    |
                          | 11            |          |                  | 9 volts AC (- phase, 50      milliamps maximum)	    |
                          | 12            |          |                  |      Ground					    |
                          | A             |          | 1                |      Ground					    |
                          | B             | FLAG2    |                  | CIA #2 handshaking      line			    |
                          | C             | PB0      | 3                | Port B Bit 0--RS-232 Received      Data (SIN)	    |
                          | D             | PB1      | 4                | Port B Bit 1--RS-232 Request      to Send (RTS)	    |
                          | E             | PB2      | 20               | Port B Bit 2--RS-232 Data      Terminal Ready (DTR) |
                          | F             | PB3      | 22               | Port B Bit 3--RS-232 Ring      Indicator (RI)	    |
                          | H             | PB4      | 8                | Port B Bit 4--RS-232 Carrier      Detect (DCD)	    |
                          | J             | PB5      |                  | Port B Bit      5				    |
                          | K             | PB6      | 5                | Port B Bit 6--RS-232 Clear to      Send (CTS)	    |
                          | L             | PB7      | 6                | Port B Bit 7--RS-232 Data Set      Ready (DSR)	    |
                          | M             | PA2      | 2                | Port A Bit 2--RS-232      Transmitted Data (Sout)   |
                          | N             |          | 7                |      Ground					    |

                          One of the handshaking lines on the above chart, PC2, was not covered
                          in the discussion of CIA #1, because that line of CIA #1 is not
                          connected to anything.  The CIA #2 PC line is accessible from the User
                          Port, however.  This line will go low for one cycle following a read
                          or write of Port B on CIA #2.  This signal lets external devices know
                          when data has been read or written.

                          Bits 0 and 1 of CIA #2 Port A have an extremely important function.
                          As mentioned in the section on the VIC-II chip (53248, $D000), the
                          video chip can address only 16K of memory at a time, and all graphics
                          data must be stored in that 16K block in order to be displayed.
                          Within this area, sprite graphics data may be placed in any of 256
                          groups of 64 bytes each.  Character data can be stored in any of eight
                          2K blocks.  Text screen memory may be in any of 16 1K areas, and
                          bitmap screen memory may be in either of two 8K sections.

                          When you turn the power on, the VIC-II uses the bottom 16K of memory
                          for graphics.  Unfortunately, this block of memory is also used
                          extensively for other important purposes.  Though some means of
                          eliminating these conflicts are discussed above, in many situations
                          you will want to change from the default 16K bank at the low end of
                          memory.

                          Bits 0 and 1 select the current 16K bank for video memory from the
                          four possible choices using the following bit patterns:

                              00 (bit value of 0) Bank 3 (49152-65535, $C000-$FFFF)
                              01 (bit value of 1) Bank 2 (32768-49151, $8000-$BFFF)
                              10 (bit value of 2) Bank 1 (16384-32767, $4000-$7FFF)
                              11 (bit value of 3) Bank 0 (0-16383, $0-$3FFF)

                          The technique for making this change from BASIC is discussed below.
                          But before we go ahead and start changing banks, let's briefly review
                          the contents of these areas, and the considerations for using them for
                          graphics.

                          Block 0.  This is normally used for system variables and BASIC program
                          text.  Locations 1024-2047 ($400-$7FF) are reserved for the default
                          position of screen memory.

                          There is an addition limitation on memory usage of this block, as the
                          VIC-II sees the character generator ROM at 4096-8191 ($1000-$1FFF),
                          making this portion of memory unavailable for other graphics data.
                          Generally, there is little free space here for graphics display data.
                          Locations 679-767 ($2A7- $2FF) are unused, and could hold one sprite
                          shape (number 11) or data for 11 characters.  The area from 820-1023
                          ($334-$3FF), which includes the cassette I/O buffer, is available for
                          graphics memory, and is large enough to hold three sprite shapes
                          (numbers 13, 14, and 15), or data for 25 characters (numbers 103-127).
                          But getting enough memory for bitmap graphics requires that you either
                          reserve memory after the end of BASIC text by lowering the end of
                          BASIC pointer at 56 ($38), or raise the start of BASIC pointer at 44
                          ($2C).  See the entries for these pointers for more details.

                          Block 1.  Block 1 is normally used for BASIC program storage.  When
                          using this bank, the VIC-II does not have access to the character
                          generator ROM.  Providing that you lower the top of memory so that
                          BASIC programs do not interfere, this area is wide open for sprite
                          shapes, character graphics, and bitmap graphics.

                          The drawbacks to using this bank are the unavailability of the
                          character ROM and the limitation on BASIC program space (as little as
                          14K).  The absence of the character ROM is a relatively minor
                          nuisance, because you can always switch in the ROM and copy any or all
                          of the characters to RAM (see the entries for location 1 and the
                          alternate entry for 53248 ($D000), the Character ROM, for details).
                          This block may be a good alternate choice to avoid potential conflicts
                          with other applications that use higher memory.

                          Block 2.  The third block (Block 2) consists of 8K of RAM, half of
                          which is seen by the VIC-II chip as character ROM, and the 8K BASIC
                          interpreter ROM.  The BASIC ROM area is available for graphics.  This
                          is possible because of the 64's special addressing.  The VIC-II chip
                          reads only from RAM, and thus sees the RAM underneath the BASIC ROM,
                          even if the 6510 has ROM switched in.  The 6510, on the other hand,
                          always writes to RAM, even when dealing with memory it reads as ROM.
                          Whatever is written to the RAM underlying the BASIC ROM is displayed
                          normally by the VIC-II chip.  This opens up an extra 8K are for
                          sprites and character data under the BASIC ROM.

                          You should keep in mind that while you can write to this area, you
                          cannot read it from BASIC.  This may not be a serious problem when it
                          comes to character sets and sprite data, but it's more of a drawback
                          if you want to use this RAM for screen memory.

                          For example, the Operating System has to read the text screen to move
                          the cursor properly, and if it reads the ROM value instead of the RAM
                          screen data, it gets hopelessly confused, making it impossible to type
                          in any commands.

                          Likewise, you would not be able to read the high-resolution screen if
                          it were placed here, without some machine language trickery.  With
                          locations 36863-40959 ousted by the character ROM, only 4K of true RAM
                          remains for use as screen memory, not enough for a complete
                          high-resolution screen.  Therefore, this block is not recommended for
                          use in bitmap mode if your program needs to check the screen.
                          Otherwise, this is a good place for graphics memory, particularly if
                          you need to emulate the screen configuration of the PET.

                          Block 3.  Normally Block 3 contains 4K of RAM that is completely
                          unused by the system, 4K if I/O registers, and the 8K Operating System
                          Kernal ROM.  It is very convenient to use when you need a lot of
                          memory space for both graphics and a BASIC program.  Although the
                          character ROM is not available, it can be copied to RAM.  The area
                          under the Kernal ROM can be used as explained above.  One possible
                          conflict that you should be aware of is that the current version of
                          the DOS support program is written to reside at 52224 ($CC00).  It
                          would be safest to avoid using 52224-53247 for graphics if you plan to
                          use DOS support.

                          Changing banks.  Once you have selected a bank of 16K to use, the
                          procedure for making the change from BASIC is as follows:

                          1.  Set the Data Direction Register if necessary.  In order to use
                          Bits 0 and 1 of Port A to change banks, these bits must be set as
                          outputs in Data Direction Register A.  Since this is the default
                          condition on powering-up, this step normally will not be needed.

                          2.  Select a bank.  Banks 0-3 can be chosen by entering the following
                          lines:

                              POKE 56578,PEEK(56578) OR 3: REM SET FOR OUTPUT IF NOT ALREADY
                              POKE 56576,(PEEK(56576) AND 252) OR (3-BANK): REM BANK IS BANK #, MUST BE 0-3

                          3.  Set the VIC-II register for character memory.  As explained at the
                          entry for location 53272 ($D018), the formula for this is:

                              POKE 53272,(PEEK(53272) AND 240) OR TK: REM TK IS 2 KBYTE OFFSET FROM BEGINNING OF BLOCK

                          4.  Set the VIC-II register for display memory.  As explained at the
                          entry for location 53272 ($D018), the formula for this is:

                          POKE 53272,(PEEK(53272) AND 15) OR K*16: REM K IS KBYTE OFFSET FROM BEGINNING OF BLOCK

                          Since steps 3 and 4 operate on the same register, you could combine
                          these steps and just POKE 53272,(16*K+TK).

                          5.  Set the Operating System pointer for display memory at 648 ($288).
                          Even though you have just told the VIC-II chip where to display memory
                          for the screen, the Operating System does not yet know where to write
                          its text characters.  Let it know with this statement:

                              POKE 648,AD/256: REM AD IS THE ACTUAL ADDRESS OF SCREEN MEMORY

                          After you make this change, you must watch out for the STOP/RESTORE
                          key combination.  The BRK initialization changes the screen display
                          default to location 1024 in Bank 0, but not the Operating System
                          pointer at 648 ($288).  As a result, what you are typing will not be
                          displayed on the screen.  The computer will lock up until you turn the
                          power off and back on again.  The simplest way to avoid this problem
                          is to disable the RESTORE key entirely (see the entries for 792 ($318)
                          and 808 ($328) for more information).

                          Below is a sample program which switches to Bank 3.  It includes a
                          machine language transfer routine to move the ROM character set to
                          RAM, and a short interrupt routine to correct the RESTORE key problem.
                          After the switch is made, a loop is used to POKE characters into the
                          new screen memory area.  Next, the character data is slowly erased, to
                          show that the character set is now in RAM.  Then, a loop is used to
                          read the locations of the character set, and write to the same
                          locations.  This demonstrates that the 6510 reads the Kernal ROM when
                          you PEEK those locations, but POKEs to the RAM which is being
                          displayed.  Finally, the machine language move is used again to show
                          how quickly the set is restored.

                              20 FOR I=1 TO 33:READ A:POKE 49152+I,A:NEXT: REM SET UP ML ROUTINE
                              30 GOSUB 200: REM ML COPY OF ROM CHARACTER SET TO RAM
                              40 POKE 56576,PEEK(56576) AND 252: REM STEP 1, ENABLE BANK 3
                              50 POKE 53272,44: REM STEPS 2-3, POINT VIC-II TO SCREEN AND CHARACTER MEMORY
                              60 REM SCREEN OFFSET IS 2*16, CHARACTER OFFSET IS 12
                              70 POKE 648,200: REM STEP 4, POINT OS TO SCREEN AT 51200 (200*256)
                              80 PRINT CHR$(147): REM CLEAR SCREEN
                              90 FOR I=53236 TO 53245:READ A:POKE I,A:NEXT: REM NEW INTERRUPT ROUTINE
                              100 POKE 53246,PEEK(792):POKE 53247,PEK(793): REM SAVE OLD NMI VECTOR
                              110 POKE 792,244:POKE 793,207: REM ROUTE THE INTERRUPT THROUGH THE NEW ROUTINE
                              120 FOR I=0 TO 255:POKE 51400+I,I:POKE 55496+I,1:NEXT
                              125 REM POKE CHARACTERS TO SCREEN
                              130 FOR J=1 TO 8:FOR I=61439+J TO I+2048 STEP 8
                              140 POKE I,0:NEXT I,J: REM ERASE CHARACTER SET
                              150 FOR I=61440 TO I+2048:POKE I,PEEK(I):NEXT: REM POKE ROM TO RAM
                              160 GOSUB 200:END: REM RESTORE CHARACTER SET
                              200 POKE 56334,PEEK(56334) AND 254: REM DISABLE INTERRUPTS
                              210 POKE 1,PEEK(1) AND 251:REM SWITCH CHARACTER ROM INTO 6510 MEMORY
                              220 SYS 49152: REM COPY ROM CHARACTER SET TO RAM AT 61440
                              230 POKE 1,PEEK(1) OR 4: REM SWITCH CHARACTER ROM OUT OF 6510 MEMORY
                              240 POKE 56334,PEEK(56334)OR 1: REM ENABLE INTERRUPTS
                              250 RETURN
                              300 REM DATA FOR ML PROGRAM TO COPY CHARACTER SET TO RAM
                              310 DATA169,0,133,251,133,253,169,208,133,252,169,240,133,254,162,16
                              320 DATA160,0,177,251,145,253,136,208,249,230,252,230,254,202,208,240,96
                              330 REM NEXT IS ML PROGRAM TO MAKE THE RESTORE KEY RESET OS POINTER TO SCREEN
                              340 DATA 72,169,4,141,136,02,104,108,254,207

                          See also the sample program showing how to configure your 64 like a
                          PET at location 43 ($2B).

$DD00        CI2PRA       Data Port Register A

                     0-1  Select the 16K VIC-II chip memory bank (11=bank 0, 00=bank 3)
                     2    RS-232 data output (Sout)/Pin M of User Port
                     3    Serial bus ATN signal output
                     4    Serial bus clock pulse output
                     5    Serial bus data output
                     6    Serial bus clock pulse input
                     7    Serial bus data input

$DD01        CI2PRB       Data Port B

                     0    RS-232 data input (SIN)/ Pin C of User Port
                     1    RS-232 request to send (RTS)/ Pin D of User Port
                     2    RS-232 data terminal ready (DTR)/ Pin E of User Port
                     3    RS-232 ring indicator (RI)/ Pin F of User Port
                     4    RS-232 carrier detect (DCD)/ Pin H of User Port
                     5    Pin J of User Port
                     6    RS-232 clear to send (CTS)/ Pin K of User Port
                          Toggle or pulse data output for Timer A
                     7    RS-232 data set ready (DSR)/ Pin L of User Port
                          Toggle or pulse data output for Timer B

$DD02-$DD03               CIA #2 Data Direction Registers A and B

                          These Data Direction registers control the direction of data flow over
                          Data Ports A and B.  For more details on the operation of these
                          registers, see the entry for the CIA #1 Data Direction Registers at
                          56322 ($DC02).

                          The default setting for Data Direction Register A is 63 (all bits
                          except 6 and 7 are outputs), and for Data Direction Register B the
                          default setting is 0 (all inputs).  Bits 1 and 2 of Port B are changed
                          to output when the RS-232 device is opened.

$DD02        C2DDRA       Data Direction Register A

                     0    Select Bit 0 of data Port A for input or output (0=input, 1=output)
                     1    Select Bit 1 of data Port A for input or output (0=input, 1=output)
                     2    Select Bit 2 of data Port A for input or output (0=input, 1=output)
                     3    Select Bit 3 of data Port A for input or output (0=input, 1=output)
                     4    Select Bit 4 of data Port A for input or output (0=input, 1=output)
                     5    Select Bit 5 of data Port A for input or output (0=input, 1=output)
                     6    Select Bit 6 of data Port A for input or output (0=input, 1=output)
                     7    Select Bit 7 of data Port A for input or output (0=input, 1=output)

$DD03        C2DDRB       Data Direction Register B

                     0    Select Bit 0 of data Port B for input or output (0=input, 1=output)
                     1    Select Bit 1 of data Port B for input or output (0=input, 1=output)
                     2    Select Bit 2 of data Port B for input or output (0=input, 1=output)
                     3    Select Bit 3 of data Port B for input or output (0=input, 1=output)
                     4    Select Bit 4 of data Port B for input or output (0=input, 1=output)
                     5    Select Bit 5 of data Port B for input or output (0=input, 1=output)
                     6    Select Bit 6 of data Port B for input or output (0=input, 1=output)
                     7    Select Bit 7 of data Port B for input or output (0=input, 1=output)

$DD04-$DD07               Timer A and B Low and High Bytes

                          These four timer registers are used to control Timers A and B.  For
                          details on the operation of these timers, see the entry for Location
                          Range 56324-56327 ($DC04-$DC07).

                          The 64 Operating System uses the CIA #2 Timers A and B mostly for
                          timing RS-232 send and receive operations.  Serial Bus timing uses CIA
                          #1 Timer B.

$DD04        TI2ALO       Timer A (low byte)

$DD05        TI2AHI       Timer A (high byte)

$DD06        TI2BLO       Timer B (low byte)

$DD07        TI2BHI       Timer B (high byte)

$DD08-$DD0B               Time of Day Clock

                          In addition to the two general purpose timers, the 6526 CIA chip has a
                          special purpose Time of Day Clock, which keeps time in a format that
                          humans can understand a little more easily than microseconds.  For
                          more information about this clock, see the entry for Location Range
                          56328-56331 ($DC08-$DC0B).  The 64's Operating system does not make
                          use of these registers.

$DD08        TO2TEN       Time of Day Clock Tenths of Seconds

                     0-3  Time of Day tenths of second digit (BCD)
                     4-7  Unused

$DD09        TO2SEC       Time of Day Clock Seconds

                     0-3  Second digit of Time of Day seconds (BCD)
                     4-6  First digit of Time of Day seconds (BCD)
                          Bit 7:  Unused

$DD0A        TO2MIN       Time of Day Clock Minutes

                     0-3  Second digit of Time of Day minutes (BCD)
                     4-6  First digit of Time of Day minutes (BCD)
                     7    Unused

$DD0B        TO2HRS       Time of Day Clock Hours

                     0-3  Second digit of Time of Day hours (BCD)
                          Bit 4:  First digit of Time of Day hours (BCD)
                     5-6  Unused
                     7    AM/PM flag (1=PM, 0=AM)

$DD0C        CI2SDR       Serial Data Port

                          The CIA chip has an on-chip serial port, which allows you to send or
                          receive a byte of data one bit at a time, with the most significant
                          bit (Bit 7) being transferred first.  For more information about its
                          use, see the entry for location 56332 ($DC0C).  The 64's Operating
                          System does not use this facility.

$DD0D        CI2ICR       Interrupt Control Register

                     0    Read / did Timer A count down to 0?  (1=yes).
                          Write/ enable or disable Timer A interrupt (1=enable, 0=disable)
                     1    Read / did Timer B count down to 0?  (1=yes).
                          Write/ enable or disable Timer B interrupt (1=enable, 0=disable)
                     2    Read / did Time of Day Clock reach the alarm time?  (1=yes).
                          Write/ enable or disable TOD clock alarm interrupt (1=enable,
                          0=disable)
                     3    Read / did the serial shift register finish a byte?  (1=yes).
                          Write/ enable or disable serial shift register interrupt (1=enable,
                          0=disable)
                     4    Read / was a signal sent on the FLAG line?  (1=yes).
                          Write/ enable or disable FLAG line interrupt (1=enable, 0=disable)
                     5    Not used
                     6    Not used
                     7    Read / did any CIA #2 source cause an interrupt?  (1=yes).
                          Write/ set or clear bits of this register (1=bits written with 1 will
                          be set, 0=bits written with 1 will be cleared)

                          This register is used to control the five interrupt sources on the
                          6526 CIA chip.  For details on its operation, see the entry for 56333
                          ($DC0D).  The main difference between these two chips pertaining to
                          this register is that on CIA #2, the FLAG line is connected to Pin B
                          of the User Port, and thus is available to the user who wishes to take
                          advantage of its ability to cause interrupts for handshaking purposes.

$DD0E-$DD0F               See locations 56334 and 56334 for details

$DD0E        CI2CRA       Control Register A

                     0    Start Timer A (1=start, 0=stop)
                     1    Select Timer A output on Port B (1=Timer A output appears on
                            Bit 6 of Port B)
                     2    Port B output mode (1=toggle Bit 6, 0=pulse Bit 6 for one
                            cycle)
                     3    Timer A run mode (1=one-shot, 0=continuous)
                     4    Force latched value to be loaded to Timer A counter (1=force
                            load strobe)
                     5    Timer A input mode (1=count microprocessor cycles, 0=count
                            signals on CNT line at pin 4 of User Port)
                     6    Serial Port (56588, $DD0C) mode (1=output, 0=input)
                     7    Time of Day Clock frequency (1=50 Hz required on TOD pin,
                            0=60 Hz)

$DD0F        CI2CRB       Control Register B

                     0    Start Timer B (1=start, 0=stop)
                     1    Select Timer B output on Port B (1=Timer B output appears on
                          Bit 7 of Port B)
                     2    Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one
                            cycle)
                     3    Timer B run mode (1=one shot, 0=continuous)
                     4    Force latched value to be loaded to Timer B counter (1=force
                            load strobe)
                     5-6  Timer B input mode
                              00 = Timer B counts microprocessor cycles
                              01 = Count signals on CNT line at pin 4 of User Port
                              10 = Count each time that Timer A counts down to 0
                              11 = Count Timer A 0's when CNT pulses are also present
                     7    Select Time of Day write (0=writing to TOD registers sets
                            alarm, 1=writing to ROD registers sets clock)

$DD10-$DDFF               CIA #2 Register Images

                          Since the CIA chip requires only enough addressing lines to handle 16
                          registers, none of the higher bits are decoded when addressing the
                          256-byte area that has been assigned to it.  The result is that every
                          16-byte area in this 256-byte block is a mirror of every other.  For
                          the sake of clarity in your programs, it is advisable not to use these
                          addresses.

$DE00-$DEFF               Reserved for I/O Expansion

                          This range of locations is not used directly by the 64's internal
                          hardware.  It is, however, accessible via pin 7 of the Expansion Port.
                          It can be used to control cartridges which are connected to this port.
                          For example, the CP/M module uses this space to control which
                          microprocessor is in control of the system.  The Z-80 microprocessor
                          is turned on and off by writing to 56832 ($DE00).

                          Another cartridge which uses this space is Simon's BASIC.  This 16K
                          cartridge is addressed at memory locations 32768-49151 ($8000-$BFFF),
                          which means that it overlaps the regular BASIC ROM at 40960-49151
                          ($A000-$BFFF).  But since it contains additions to BASIC, it must use
                          the BASIC ROM as well.  This problem is solved by copying the
                          cartridge at 32768-40959 ($8000-$9FFF) to RAM, and turning the
                          cartridge on and off by writing to or reading from location 56832
                          ($DE00).

$DF00-$DFFF               CIA #2 Register Images

                          This range of locations is not used directly by the 64's internal
                          hardware, but is accessible via pin 10 of the Expansion Port.  One
                          possible use for this I/O memory that Commodore has mentioned is an
                          inexpensive parallel disk drive (which presumable would be much faster
                          than the current serial model).

                          Alternate 53248-57343 ($D000-$DFFF)
                          Character Generator ROM

                          The character generator ROM supplies the data which is to form the
                          shapes of the text and graphics characters that are displayed on the
                          screen.  Each character requires eight bytes of shape data, and these
                          eight-byte sequences are arranged in order in which the characters
                          appear in the screen code chart (see Appendix G).  For example, the
                          first eight bytes of data in the ROM hold the shape information for
                          the commercial at sign (@), the next eight hold the shape of the
                          letter A, etc.  In all, there are 4096 bytes, representing shape data
                          for two complete character sets of 256 characters each--1K each for
                          uppercase/graphics, reverse uppercase/reverse graphics, lowercase/
                          uppercase, and reverse lowercase/reverse uppercase.

                          The shape of each character is formed by an 8 by 8 matrix of screen
                          dots.  Whether any of the 64 dots is lit up or not is determined by
                          the bit patterns of the character data.  Each byte of the Character
                          ROM holds a number from 0 to 255.  This number can be represented by
                          eight binary digits of 0 or 1.  The leftmost bit of these eight is
                          known as Bit 7, while the rightmost bit is called Bit 0.  Each of
                          these binary digits has a bit value that is two times greater than the
                          last.  The values of a bit set to 1 in each of the bit places are:

                          |       |   |   |   |   |    |    |    |     |
                          |-------|---|---|---|---|----|----|----|-----|
                          | Bit   | 0 | 1 | 2 | 3 |  4 |  5 |  6 |   7 |
                          | Value | 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 |

                          A byte whose value is 255 has every bit set to 1
                          (128+64+32+16+8+4+2+1=255), while a byte whose value is 0 is made up
                          of all zero bits.  Numbers in between are made up of combinations of
                          bits set to 1 and bits set to 0.  If you think of every bit that holds
                          0 as a dot on the screen which is the color of the screen background,
                          and every bit that holds a 1 as a dot whose color is that of the
                          appropriate nybble in Color RAM, you can begin to get an idea of how
                          the byte values relate to the shape of the character.  For example, if
                          you PEEK at the first eight bytes of the character ROM (the technique
                          is explained in the entry for location 1), you will see the numbers
                          60, 102, 110, 110, 96, 98, 60, 0.  Breaking these data bytes down into
                          their bit values gives us a picture that looks like the following:

                              00111100   0 +   0 +  32 +  16 +   8 +   4 +   0 +   0 =  60
                              01100110   0 +  64 +  32 +   0 +   0 +   4 +   2 +   0 = 101
                              01101110   0 +  64 +  32 +   0 +   8 +   4 +   2 +   0 = 110
                              01101110   0 +  64 +  32 +   0 +   8 +   4 +   2 +   0 = 110
                              01100000   0 +  64 +  32 +   0 +   0 +   0 +   0 +   0 =  96
                              01100010   0 +  64 +  32 +   0 +   0 +   0 +   2 +   0 =  98
                              00111100   0 +   0 +  32 +  16 +   8 +   4 +   0 +   0 =  60
                              00000000   0 +   0 +   0 +   0 +   0 +   0 +   0 +   0 =   0

                          If you look closely, you will recognize the shape of the commercial at
                          sign (@) as it's displayed on your screen.  The first byte of data is
                          60, and you can see that Bits 5, 4, 3, and 2 are set to 1.  The chart
                          above shows that the bit values for these bits are 32, 16, 8, and 4.
                          Adding these together, you get 32+16+8+4=60.  This should give you an
                          idea of how the byte value corresponds to the patterns of lit dots.
                          For an even more graphic display, type in the following program, which
                          shows the shape of any of the 512 characters in the ROM, along with
                          the number value of each byte of the shape.

                              10 DIM B%(7),T%(7):FOR I=0 TO 7:T%(I)=2^I:NEXT
                              20 POKE 53281,2:PRINT CHR$(147):POKE 53281,1:POKE 53280,0:POKE 646,11
                              30 POKE 214,20:PRINT:INPUT" CHARACTER NUMBER (0-511)";C$
                              40 C=VAL(C$):GOSUB 80:FOR I=0 TO 7
                              50 POKE 214,6+I:PRINT:PRINT TAB(23);B%(I);CHR$(20);"   "
                              60 FOR J=7 TO 0 STEP-1:POKE 1319+(7-J)+I*40,32-128*((B%(I)ANDT%(J))=T%(J))
                              70 NEXT J,I:POKE 214,20:PRINT:PRINT TAB(27)"    ":GOTO 30
                              80 POKE 56333,127:POKE 1,51:FOR I=0 TO 7
                              90 B%(I)=PEEK(53248+C*8+I):NEXT:POKE 1,55:POKE 56333,129:RETURN

                          If you have read about the VIC-II video chip, you know that it can
                          address only 16K of memory at a time, and that all display data such
                          as screen memory, character shape data, and sprite shape data must be
                          stored within that 16K block.

                          Since it would be very inconvenient for the VIC-II chip to be able to
                          access the character data only at the 16K block which includes
                          addresses 53248-57343 ($D000-$DFFF), the 64 uses an addressing trick
                          that makes the VIC-II chip see an image of the Character ROM at
                          4096-8191 ($1000-$1FFF) and at 36864-40959 ($9000-$9FFF).  It is not
                          available in the other two blocks.  To generate characters in these
                          blocks, you must supply your own user-defined character set, or copy
                          the ROM data to RAM.  A machine language routine for doing this is
                          included in a sample program at the entry for 56576 ($DD00).

                          As indicated above, you are by no means limited to using the
                          character data furnished by the ROM.  The availability of user-defined
                          characters greatly extends the graphics power of the 64.  It allows
                          you to create special text characters, like math or chemistry symbols
                          and foreign language alphabets.  You can also develop special graphics
                          characters as a substitute for plotting points in bitmap graphics.
                          You can achieve the same resolution using a custom character as in
                          high-resolution bitmap mode, but with less memory. Once you have
                          defined the character, it is much faster to print it to the screen
                          than in would be to plot out all of the individual points.

                          To employ user-defined characters, you must first pick a spot to put
                          the shape data.  This requires choosing a bank of 16K for video chip
                          memory (see the entry under Bits 0-1 of 56576 ($DD00) for the
                          considerations involved), and setting the pointer to the 2K area of
                          character memory in 53272 ($D018).  It is then up to you to supply the
                          shape data for the characters.  You can use part of the ROM character
                          set by reading the ROM and transferring the data to your character
                          shape area (see the entry for location 1 for a method of reading the
                          ROM).

                          Your original characters may be created by darkening squares on an 8
                          by 8 grid, converting all darkened squares to their bit values, and
                          then adding the bit values for each of the eight bytes.  Or, you may
                          use one of the many character graphics editor programs that are
                          available commercially to generate the data interactively by drawing
                          on the screen.

                          One graphics mode, multicolor text mode, almost requires that you
                          define your own character set in order to use it effectively.
                          Multicolor mode is enabled by Bit 4 of location 53270 ($D016).
                          Instead of using each bit to control whether an individual dot will be
                          foreground color (1) or background color (0), that mode breaks down
                          each byte of shape data in four bit-pairs.  These bit pairs control
                          whether a dot will be the color in Background Color Register #0 (00),
                          the color in Background Color Register #1 (01), the color in
                          Background Color Register #2 (10), or the color in the appropriate
                          nybble of Color RAM (11).  Since each pair of bits controls one dot,
                          each character is only four dots across.  To make up for this, each
                          dot is twice as wide as a normal high-resolution dot.

